
\begin{ccRefClass}{Min_circle_2<Traits>}

\ccIndexSubitem       [t]{circle }{smallest enclosing}
\ccIndexSubitemSeeAlso[t]{ellipse}{smallest enclosing circle}
\ccIndexSubitemSeeAlso[t]{sphere }{smallest enclosing circle}
\ccIndexSubitem       [t]{smallest enclosing}{circle}
\ccIndexSubitem       [t]{bounding volumes}{smallest enclosing circle}

\ccSaveThreeColumns
\cgalMinCircleLayout

% -----------------------------------------------------------------------------
\ccDefinition

An object of the class \ccRefName\ is the unique circle of smallest area
enclosing a finite (multi)set of points in two-dimensional Euclidean
space~$\E^2$.  For a point set $P$ we denote by $mc(P)$ the smallest circle
that contains all points of $P$. Note that $mc(P)$ can be
degenerate\lcTex{\ccIndexSubitem[t]{degeneracies}{\ccFont Min_circle_2}},
i.e.~$mc(P)=\emptyset$ if
$P=\emptyset$ and $mc(P)=\{p\}$ if
$P=\{p\}$.

An inclusion-minimal subset $S$ of $P$ with $mc(S)=mc(P)$ is called a
\emph{support set}\lcTex{\ccIndexSubitem[t]{support set}{\ccFont Min_circle_2}},
the points in $S$ are the \emph{support points}.  A support set has size at
most three, and all its points lie on the boundary of $mc(P)$. In general,
neither the support set nor its size are necessarily unique.

The underlying algorithm can cope with all kinds of input, e.g.~$P$ may be
empty or points may occur more than once. The algorithm computes a support
set $S$ which remains fixed until the next insert or clear operation.

{\bf Please note:} This class is (almost) obsolete. The class
\ccc{CGAL::Min_sphere_of_spheres_d<Traits>} solves a more general problem
and is faster then \ccRefName\, even if used only for points in two
dimensions as input. Most importantly, 
\ccc{CGAL::Min_sphere_of_spheres_d<Traits>} has
a specialized implementation for floating-point arithmetic which
ensures correct results in a large number of cases (including
highly degenerate ones). In contrast, \ccRefName\ is not tuned for
floating-point computations. The only advantage of 
\ccRefName\ over \ccc{CGAL::Min_sphere_of_spheres_d<Traits>} is that the
former can deal with points in homogeneous coordinates, in which 
case the algorithm is division-free. Thus, \ccRefName\ might still
be an option in case your input number type cannot (efficiently) 
divide.

\ccInclude{CGAL/Min_circle_2.h}

% -----------------------------------------------------------------------------
\ccRequirements
\ccIndexRequirements

The template parameter \ccc{Traits} is a model for \ccc{MinCircle2Traits}.

We provide the model \ccc{CGAL::Min_circle_2_traits_2} using the 
two-dimensional \cgal~kernel.

% -----------------------------------------------------------------------------
\ccTypes
\ccIndexClassTypes

\ccSetTwoColumns{\ccRefName:: Circle}{}

\ccNestedType{ Point }{ typedef to \ccc{Traits::Point }.}

\ccNestedType{ Circle}{ typedef to \ccc{Traits::Circle}.}

\ccNestedType{ Point_iterator}{
        non-mutable model of the \stl\ concept \emph{BidirectionalIterator}
        with value type \ccc{Point}. Used to access the points
        of the smallest enclosing circle.}

\ccNestedType{ Support_point_iterator}{
        non-mutable model of the \stl\ concept \emph{RandomAccessIterator}
        with value type \ccc{Point}. Used to access the support points
        of the smallest enclosing circle.}

\ccPropagateThreeToTwoColumns

% -----------------------------------------------------------------------------
\ccCreation
\ccIndexClassCreation
\ccCreationVariable{min_circle}

A \ccRefName\ object can be created from an arbitrary point set $P$ and by
specialized construction methods expecting no, one, two or three points as
arguments. The latter methods can be useful for reconstructing $mc(P)$ from
a given support~set\lcTex{\ccIndexSubitem[t]{support set}{\ccFont Min_circle_2}}
$S$ of $P$.

\ccConstructor{ template < class InputIterator >
                Min_circle_2( InputIterator  first,
                              InputIterator  last,
                              bool           randomize,
                              Random&        random    = CGAL::default_random,
                              const Traits&  traits    = Traits()   );}{
        initializes \ccVar\ to $mc(P)$ with $P$ being the set of points
        in the range [\ccc{first},\ccc{last}). If \ccc{randomize} is
        \ccc{true}, a random permutation of $P$ is computed in
        advance, using the random numbers generator \ccc{random}.
        Usually, this will not be necessary, however, the algorithm's
        efficiency depends on the order in which the points are
        processed, and a bad order might lead to extremely poor
        performance (see example below).
        \ccRequire The value type of \ccc{first} and \ccc{last}
        is \ccc{Point}.}

\ccConstructor{ Min_circle_2( const Traits&  traits = Traits());}{
        initializes \ccVar\ to
        $mc(\emptyset)$, the empty set.
        \ccPostcond  \ccVar\ccc{.is_empty()} = \ccc{true}.}

\ccConstructor{ Min_circle_2( const Point&   p,
                              const Traits&  traits = Traits());}{
        initializes \ccVar\ to $mc(\{p\})$, the set $\{p\}$.
        \ccPostcond  \ccVar\ccc{.is_degenerate()} = \ccc{true}.}

\ccConstructor{ Min_circle_2( const Point&   p1,
                              const Point&   p2,
                              const Traits&  traits = Traits());}{
        initializes \ccVar\ to $mc(\{p1,p2\})$, the circle with diameter
        equal to the segment connecting $p1$ and $p2$.}

\ccConstructor{ Min_circle_2( const Point&   p1,
                              const Point&   p2,
                              const Point&   p3,
                              const Traits&  traits = Traits());}{
        initializes \ccVar\ to $mc(\{p1,p2,p3\})$.}

% -----------------------------------------------------------------------------
\ccAccessFunctions
\begin{ccIndexMemberFunctions}
\ccIndexMemberFunctionGroup{access}

\ccMemberFunction{ int  number_of_points( ) const;}{
        returns the number of points of \ccVar, i.e.\ $|P|$.}

\ccMemberFunction{ int  number_of_support_points( ) const;}{
        returns the number of support points of \ccVar, i.e.\ $|S|$.}
\lcTex{\ccIndexSubitem[t]{support set}{\ccFont Min_circle_2}}

\ccGlueBegin
\ccMemberFunction{ Point_iterator  points_begin() const;}{
        returns an iterator referring to the first point of \ccVar.}
%
\ccMemberFunction{ Point_iterator  points_end() const;}{
        returns the corresponding past-the-end iterator.}
\ccGlueEnd

\ccGlueBegin
\ccMemberFunction{ Support_point_iterator  support_points_begin() const;}{
        returns an iterator referring to the first support point of \ccVar.}
%
\ccMemberFunction{ Support_point_iterator  support_points_end() const;}{
        returns the corresponding past-the-end iterator.}
\ccGlueEnd

\ccMemberFunction{ const Point&  support_point( int i) const;}{
        returns the \ccc{i}-th support point of \ccVar. Between two
        modifying operations (see below) any call to
        \ccVar\ccc{.support_point(i)} with the same \ccc{i} returns
        the same point.
        \ccPrecond $0 \leq i< \mbox{\ccVar\ccc{.number_of_support_points()}}$.}

\ccMemberFunction{ const Circle&  circle( ) const;}{
        returns the current circle of \ccVar.}

% -----------------------------------------------------------------------------
\ccPredicates
\ccIndexMemberFunctionGroup{predicates}

By definition, an empty \ccClassTemplateName\ has no boundary and no
bounded side, i.e.\ its unbounded side equals the whole space $\E^2$.

\ccMemberFunction{ CGAL::Bounded_side
                   bounded_side( const Point& p) const;}{
        returns \ccGlobalScope\ccc{ON_BOUNDED_SIDE},
        \ccGlobalScope\ccc{ON_BOUNDARY}, or
        \ccGlobalScope\ccc{ON_UNBOUNDED_SIDE} iff \ccc{p} lies properly
        inside, on the boundary of, or properly outside of \ccVar, resp.}

\ccMemberFunction{ bool  has_on_bounded_side( const Point& p) const;}{
        returns \ccc{true}, iff \ccc{p} lies properly inside \ccVar.}

\ccMemberFunction{ bool  has_on_boundary( const Point& p) const;}{
        returns \ccc{true}, iff \ccc{p} lies on the boundary
        of \ccVar.}

\ccMemberFunction{ bool  has_on_unbounded_side( const Point& p) const;}{
        returns \ccc{true}, iff \ccc{p} lies properly outside of \ccVar.}

\ccMemberFunction{ bool  is_empty( ) const;}{
        returns \ccc{true}, iff \ccVar\ is empty (this implies
        degeneracy).}

\ccMemberFunction{ bool  is_degenerate( ) const;}{
        returns \ccc{true}, iff \ccVar\ is degenerate,
        i.e.~if \ccVar\ is empty or equal to a single point, equivalently
        if the number of support points is less than 2.}
\lcTex{\ccIndexSubitem[t]{degeneracies}{\ccFont Min_circle_2}}

% -----------------------------------------------------------------------------
\ccModifiers
\ccIndexMemberFunctionGroup{modifiers}

New points can be added to an existing \ccVar, allowing to build $mc(P)$
incrementally, e.g.~if $P$ is not known in advance. Compared to the direct
creation of $mc(P)$, this is not much slower, because the construction
method is incremental itself.

\ccMemberFunction{ void  insert( const Point& p);}{
        inserts \ccc{p} into \ccVar\ and recomputes the smallest
        enclosing circle.}

\ccMemberFunction{ template < class InputIterator >
                   void  insert( InputIterator  first,
                                 InputIterator  last );}{
        inserts the points in the range [\ccc{first},\ccc{last})
        into \ccVar\ and recomputes the smallest enclosing circle by
        calling \ccc{insert(p)} for each point \ccc{p} in
        [\ccc{first},\ccc{last}).
        \ccRequire  The value type of \ccc{first} and \ccc{last} is
        \ccc{Point}.}

\ccMemberFunction{ void clear( );}{
        deletes all points in \ccVar\ and sets \ccVar\ to the empty set.
        \ccPostcond  \ccVar\ccc{.is_empty()} = \ccc{true}.}

% -----------------------------------------------------------------------------
\ccHeading{Validity Check}
\ccIndexMemberFunctionGroup{validity check}
\lcTex{\ccIndexSubitem[t]{validity check}{\ccFont Min_circle_2}}

An object \ccVar\ is valid, iff
\begin{itemize}
  \item \ccVar\ contains all points of its defining set $P$,
  \item \ccVar\ is the smallest circle spanned by its support set $S$, and
  \item $S$ is minimal, i.e.\ no support point is redundant.
\end{itemize}

\ccMemberFunction{ bool is_valid( bool verbose = false,
                                  int  level   = 0    ) const;}{
      returns \ccc{true}, iff \ccVar\ is valid. If \ccc{verbose}
      is \ccc{true}, some messages concerning the performed checks
      are written to standard error stream. The second parameter
      \ccc{level} is not used, we provide it only for consistency
      with interfaces of other classes.}

% -----------------------------------------------------------------------------
\ccHeading{Miscellaneous}
\ccIndexMemberFunctionGroup{miscellaneous}

\def\ccTagRmConstRefPair{\ccFalse}

\ccMemberFunction{ const Traits&  traits( ) const;}{
        returns a const reference to the traits class object.}

\def\ccTagRmConstRefPair{\ccTrue}

\end{ccIndexMemberFunctions}

% -----------------------------------------------------------------------------
\ccHeading{I/O}
\begin{ccIndexGlobalFunctions}

\ccIndexGlobalFunctionGroup{output}
\ccFunction{ std::ostream&
             operator << ( std::ostream& os,
                           const Min_circle_2<Traits>& min_circle);}{
        writes \ccVar\ to output stream \ccc{os}.
        \ccRequire  The output operator is defined for \ccc{Point}
        (and for \ccc{Circle}, if pretty printing is used).}

\ccIndexGlobalFunctionGroup{input}
\ccFunction{ std::istream&
             operator >> ( std::istream& is,
                           Min_circle_2<Traits> min_circle&);}{
        reads \ccVar\ from input stream \ccc{is}.
        \ccRequire  The input operator is defined for \ccc{Point}.}

\end{ccIndexGlobalFunctions}

% -----------------------------------------------------------------------------
\ccSeeAlso

\ccRefIdfierPage{CGAL::Min_ellipse_2<Traits>}\\
\ccRefIdfierPage{CGAL::Min_sphere_d<Traits>}\\[1ex]
\ccRefIdfierPage{CGAL::Min_sphere_of_spheres_d<Traits>}\\[1ex]
\ccRefIdfierPage{CGAL::Min_circle_2_traits_2<K>}\\[1ex]
\ccRefConceptPage{MinCircle2Traits}

% -----------------------------------------------------------------------------
\ccImplementation
\ccIndexImplementation

We implement the incremental algorithm\lcTex{\ccIndexSubitem[t]{incremental
  algorithm}{\ccFont Min_circle_2}} of Welzl, with move-to-front
heuristic~\cite{w-sedbe-91a}\lcTex{\ccIndexSubitem[t]{move-to-front
  heuristic}{\ccFont Min_circle_2}}. The whole implementation is described
in~\cite{cgal:gs-seceg-98}.

If randomization\lcTex{\ccIndexSubitem[t]{randomization}{\ccFont Min_circle_2}} is
chosen, the creation time is almost always linear in the number of points.
Access functions and predicates take constant time, inserting a point might
take up to linear time, but substantially less than computing the new
smallest enclosing circle from scratch. The clear operation and the check
for validity each takes linear time.

% -----------------------------------------------------------------------------
\ccExample
\ccIndexSubitem[C]{Min_circle_2}{example}

To illustrate the creation of \ccRefName\ and to show that
randomization can be useful in certain cases, we give an example.

\ccIncludeExampleCode{Min_circle_2/min_circle_2.cpp}

% -----------------------------------------------------------------------------

\ccRestoreThreeColumns

\end{ccRefClass}


