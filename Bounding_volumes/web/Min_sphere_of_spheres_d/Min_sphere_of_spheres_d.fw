%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Documentation and source code for the smallest ball enclosing balls code
%
% This work has been developed and written at the Institute of Theoretical
% Computer Science at the ETH Zurich.  Many thanks to my advisor Bernd
% Gaertner.
%
% $Id$ ($Date$)
%
% Contact: Kaspar Fischer <fischerk@@inf.ethz.ch>
%
% WARNING: Equation numbers have been manually inserted into routine compare().
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
@p typesetter = tex
@p maximum_input_line_length = 200
\documentclass[a4paper,titlepage]{article}
\setlength{\hoffset}{-0.9cm}
\setlength{\textwidth}{14cm}
\usepackage{html}
\usepackage[dvips]{graphics,color,epsfig}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{ifthen}
\usepackage{psfrag}
%\usepackage[multiple]{footmisc}
\input{Funnelweb}
%
%\newcommand{\note}[1]{}%
\newcommand{\note}[1]{#1}%
%
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
%%
\newenvironment{warning}{\medskip\begin{quote}{\bf Warning.}}{\end{quote}}
\newenvironment{remark}{\medskip\begin{quote}{\bf Remark.}}{\end{quote}}
%
%
\newcommand{\code}[1]{{\tt #1}}%
\newenvironment{fdesclist}{\begin{description}}{\end{description}}
\newenvironment{fdescitem}[3]{%
\item{\tt\begin{tabular}{#1}#2\end{tabular}\hfill{\rm #3}}\\}{}%
%
\newcommand{\descset}[2]{\ensuremath{\{ #1\,\,|\,\,\mbox{#2} \} }}
\newcommand{\angl}[1]{\ensuremath{\langle {#1}\rangle}}
%
\newcommand{\e}[1]{\emph{#1}}
\newcommand{\q}[1]{\ensuremath{\overline{#1}}}
\newcommand{\aff}{\ensuremath{\mathop{\rm aff}\nolimits}}
\newcommand{\conv}{\ensuremath{\mathop{\rm conv}\nolimits}}
\newcommand{\sgn}{\ensuremath{\mathop{\rm sgn}\nolimits}}
\newcommand{\supp}{\ensuremath{\mathop{\rm Supp}\nolimits}}
\newcommand{\ex}{\ensuremath{\mathop{\rm ex}\nolimits}}
%
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\M}{\ensuremath{\mathbb{M}}}
\newcommand{\Q}{\ensuremath{\mathbb{Q}}}
\newcommand{\C}{\ensuremath{\mathbb{C}}}
%
\newcommand{\MB}{\ensuremath{\mathop{\textsc{mb}}\nolimits}}
\newcommand{\MBR}{\ensuremath{\mathop{\textsc{mbr}}\nolimits}}
%
\setlength{\parindent}{0pt}
%
\bibliographystyle{plain}
%
\title{Fast and robust miniball of balls}
\author{Kaspar Fischer \\
Advisor: Bernd G\"artner \\
Institute for Theoretical Computer Science \\
ETH Z\"urich}
\date{February 19, 2003}
%
%
\begin{document}
\maketitle
%
\pagebreak
\tableofcontents
\pagebreak
%
\section{Introduction}
%
The work on this program began in the winter of 2001 when I started my
diploma thesis at ETH Z\"urich, under guidance by Bernd G\"artner.  At
this time, only Megiddo's algorithm~\cite{m-bsb-89} was known to solve
the miniball problem (of balls), and we hadn't heard of any
implementation thereof.  But there was Emo Welzl's elegant
algorithm~\cite{w-sedbe-91a} to solve the less general problem of
finding the miniball of a given set of points.  We took this as our
starting point, with the goal to either generalize his algorithm or to
disprove its correctness in the domain of balls.  Amazingly, the
latter was the case and we found an example where Welzl's algorithm
didn't work when generalized to balls in the straightforward
manner.\footnote{As a side result, this also showed that a program,
which was circulating on the internet for quite some time and which
was thought to find the miniball of balls (because it was based on
Welzl's point algorithm), was incorrect.}\par\medskip
%
Luckily, there was another track to follow.  Since the
miniball-of-balls problem lies in the class of so-called \e{LP-type}
problems~\cite{msw-sblp-92}, we could use the \e{LP-algorithm} to
tackle it.  This algorithm, being quite similar in spirit to Welzl's
``original'' algorithm, solves any LP-type problem as long as two
``primitive operations'' are available.  So all we needed to do was to
develop these primtives for our specific problem.\par\medskip
%
This document describes an implementation of the LP-algorithm, adapted
to the miniball problem, and of a heuristic.\footnote{We call it a
``heuristic'' because it doesn't come with any guarantee on the
running time.  The ball it com\-putes is minimal, though, it's not
just an approximation.}  Using the material
from~\cite{fg-sebbcsa-03,f-sebb-01} we develop the needed primitives
and provide code in \code{C++} to compute the exact miniball (using
multiple-precision numbers) as well as a floating-point approximation
of it.\footnote{The word ``approximation'' might be missleading here:
Our algorithm is \e{not} an approximation algorithm, i.e., it is not
an algorithm which only computes a ``small'' enclosing ball---our
algorithm computes the \e{smallest} enclosing ball; however, due to
rounding-errors, the result might not be exact.}
%
The resulting package is part of \htmladdnormallinkfoot{{\sc
Cgal}}{http://www.cgal.org}, the \e{Computational Geometry Algorithms
Library} developed in a joint effort at several universities.
However, the package is also ``stand-alone,'' which means that it
works without having {\sc Cgal} installed.  The specification of the
provided routines and data-structures is presented in
section~\ref{sect_specification}; in case you are using the code from
within {\sc Cgal} you might want to throw a glance at the {\sc Cgal}
user and reference manual, too.\par\medskip
%
Many people have in some way or another contributed to this package,
see file~\code{thanks.txt}.  In particular I would like to thank my
advisor Bernd G\"artner for his constant support!
%
%
\section{The specification}\label{sect_specification}
%
This section states the miniball problem and presents the public
interface of the data-structures and routines provided by this package.
Also, this section explains how to adapt the package to your code (so
you can use your ``ball'' type with it).  In case you intend to use
the package, then this is the (only) section you need to read.
%
\subsection{The problem}
%
In~$\R^d$-space, a \e{ball}~$B$ with center~$c_B$ and non-negative
radius~$\rho_B\ge 0$ is the closed set $B =
\descset{x\in\R^d}{$\|x-c_B\|\le \rho_B$}$.
%We often write $B=\ball(c_B,\rho_B)$ as a short hand for this set.
When we talk about sets $\{B_1,\ldots,B_k\}$ of balls, we write $c_i$
to denote the center of ball~$B_i$ and use $\rho_i$ for its radius.
%
\begin{definition}
Given a set $S = \{B_1,\ldots,B_n\}$ of balls, the \e{miniball
$\MB(S)$ of~$S$} is the ball $B\subseteq\R^d$ of minimal radius which
encloses all balls in~$S$.  For $S = \emptyset$, we define
$\MB(\emptyset) = \emptyset$.  A subset~$R\subseteq S$ of minimal size
satisfying $\MB(S)=\MB(R)$ is called a \e{basis} of~$S$.
\end{definition}
%
Figure~\ref{fig_mb_ex} shows two sets~$S$ of four balls in the
plane~$\R^2$ and their respective miniballs (dashed).  (For
simplicity, the examples in this document are in two dimensions, but
the program works in general $\R^d$-space.)  In the left example, the
set $R=\{B_1,B_3,B_4\}$ forms a basis of~$S$, on the right-hand side
$R=\{B_1,R_3\}$ is one.  It is well-known that a basis consist of at
most~$d+1$ balls.\par\medskip
%
\begin{figure}[tbhp]
\begin{center}
\includegraphics{figs/mbex/mbex.eps}
\caption{\label{fig_mb_ex}Two examples illustrating the smallest
enclosing ball.}
\end{center}
\end{figure}
%
In general, the radius and the Euclidean center coordinates of the
miniball of a set of balls with radii and coordinates in~$\R$ need not
be rational.  Consequently, the algorithm computing the exact miniball
will have to deal with algebraic numbers.  Fortunately, both the
radius and the coordinates of the miniball are (in the worst case)
numbers of the form $a_i+b_i\sqrt{t}$, where $a_i,b_i,t\in \Q$ and
where $t\ge 0$ is the same for the radius and all coordinates.  Thus,
the exact miniball can be described by the number~$t$, which we will
call the ball's \e{discriminant}\label{disc}, and $d+1$ pairs
$(a_i,b_i)\in\Q^2$ (one for the radius and $d$ for the center
coordinates).\par\medskip
%
We will use the following notion. A point~$p$ is said to lie on the
boundary of a certain ball~$B$ if it lies at distance~$\rho_B$ from
the ball's center~$c_B$, i.e., if $\partial B \cap \{p\} \not=
\emptyset$.  For a ball $B'$ we say that ball $B'$ lies \e{on the
boundary} of~$B$ (or alternatively, is a \e{supporting ball} of~$B$)
if and only if $B'\subseteq B$ and $\partial B \cap B' \not=
\emptyset$; in words, $B'$ lies on the boundary of $B$ if $B'$ is
contained in $B$ and tangent to~$B$.  In the left-hand example of
figure~\ref{fig_mb_ex}, $B_4$ and $B_1$ are supporting balls of
$\MB(\{B_1,\ldots,B_4\})$, while $B_2$ is not.
%
\subsection{The interface to the package}\label{sect_interface}
%
All the data-structures and all code of the package is defined inside
the namespace \code{CGAL}.  To use the package you have to include the
header file \code{CGAL/Min\_sphere\_of\_spheres\_d.h}.  It is possible to
adjust certain options by altering the content of the file
\code{CGAL/Min\_sphere\_\-of\_spheres\_d\_configure.h}, see file
\code{README}.
%
\begin{warning}\label{changecode}
I strongly discourage from changing
the package's source code.  By not changing the source, you can easily
profit from bug-fixes and new releases.  Also, I might be able to help
you in case of problems, which is not possible if we do not share the
same source code.
\end{warning}
%
As far as compilers are concerned, the following table\footnote{The
last two colums contain the running times of the program
\code{benchmark} from the test-suite, which computes the miniball of
one million random balls in 3D using \code{double} floating-point
arithmetic.  The program was compiled with assertions disabled, was
run ten times and the average running time was taken.  The first of
the two columns contains the running time when the algorithm is told
to avoid square-root computations and the last column contains the
running time when it is advised to extract square-roots (cf.\
\code{Use\_square\_roots} in section~\ref{sect_int_mini}).  The
program \code{benchmark} is listed in section~\ref{sect_example}.}
gives you an overview of those platforms/compilers on which the
package's test-suite is known to complete.  Please send me an email if
you have successfully run the test-suite on some other platform.
Should you experience compilation errors let me know as well, so that
I can make the code more portable.\par\medskip
%
\begin{center}
\begin{tabular}{|p{4.5cm}|p{2cm}|c|c|}
\hline
Platform & Compiler & Benchmark & Benchmark-Sqrt \\
\hline
\hline
Windows 2000 Pro.\ 5.0.2195\par
Sony Vaio 80686 695Mhz\par
i686-pc-cygwin
& {\sc gcc}\par 2.95.2-9 & 1.60s & 1.27s \\
\hline
Windows 2000 Pro.\ 5.0.2195\par
Sony Vaio 80686 695Mhz\par
& Visual C++\par 13.00.9466 & 2.17s & 1.40s \\
\hline
MacOS X 10.1.5\par
PowerBook G4 550Mhz\par
powerpc-apple-darwin5.5  & {\sc gcc} \par 2.95.2 & 1.98s & 4.00s \\
\hline
\end{tabular}
\end{center}\par\medskip
%
Because the package makes use of language features like templates, it
is a good idea to turn on code optimization.  If you use a good
compiler, this results in practically no overhead (compared to a
version of the program without templates, etc.).
%
\begin{warning}
As already mentioned, this package can compute the exact miniball
(using arbitrary-precision numbers) as well as a floating-point
approximation to the miniball.  In the latter case, the package
doesn't give you any (strict) guarantee that the computed ball is
indeed the smallest enclosing ball.  In fact, since (finite-precision)
floating-point numbers are used to calculate and represent the ball,
the result will almost always be inexact. However, the involved
relative error (in the radius and the coordinates) is usually very
small and thus sufficient for most applications.
%(Please refer also to routine \code{accuracy()} in
%section~\ref{sect_int_mini}.)
Nonetheless, let it be said that, although we tried hard to make the
program robust and although we haven't experienced any problems so
far, the program \e{might} produce unsatisfactory results in some
cases.  (When you compute the \e{exact} miniball, then the result is
always correct, of course.)  Please contact me if you are the chosen
one to run into such problems.
\end{warning}
%
\subsubsection{The traits class}\label{sect_traits}
%
Since the package doesn't know about the type of the balls you want to
compute the miniball of, you have to tell it.  This you do by writing
a so-called \e{traits class}.  Inside this class you provide (by means
of typedefs and inline functions) the name of your ball-type and
routines to access a ball's radius and coordinates.  This way, the
package knows how to deal with your ball-type.\par\medskip
%
Recall that an exact number type is a number type which evaluates
operations on numbers (like addition, substraction, multiplication and
division, but also comparision, etc.) exactly, i.e., without
(rounding) errors.
%
\begin{definition}
A class $T$ is called a \e{miniball traits class} if it satisfies the
following:
\begin{enumerate}
%
\item The type \code{T::FT} is a typedef to the type of the
individual coordinates and of the radius of a ball.  As is further
described below, \code{T::FT} must either be \code{double}
or \code{float}, or
some exact number-type supporting the four basic arithmetic
operations.  The package will create instances of this type to
compute intermediate results, and for this purpose \code{T::FT}
must provide a default constructor and a conversion constructor
\code{T::FT(int)}.  Furthermore, if \code{T::FT} is an
exact number type, then there must exist a function \code{double
to\_double(const FT\& x)}, which produces a double
approximation of~\code{x}.
%
\item The type \code{T::Sphere} is a typedef to your
ball-type. Semantically, an instance of this type must have a center
$c$ (consisting of $d$ Euclidean coordinates) and a radius $\rho\ge
0$.  The type of the individual coordinates and of the radius must be
\code{T::FT}.  The type \code{T::Sphere} must provide a copy constructor.
%
\item The integer \code{static const int Traits::D} specifies the
dimension $d$ of your balls.
%
\item The type \code{T::Cartesian\_const\_iterator} is a const-iterator to iterate
over the $d$ coordinates of a ball's center.
%
\item The (static or non-static) function
  \code{Cartesian\_const\_iterator T::cen\-ter\_\-car\-te\-sian\_\-begin(const
    Sphe\-re\& b)} returns a const-iterator to the beginning of the
  coordinates of the ball $b$.
%
\item The function
%
\code{const FT\& T::radius(const Sphere\& b)}
%
(which may be a static or non-static member of \code{T}) returns the
radius of ball $b$.
%
\item The type \code{T::Algorithm} should typedef to one of the types
mentioned below.
%
\item The type \code{T::Use\_square\_roots} should typedef to either
the type \code{CGAL::Tag\_true} or \code{CGAL::Tag\_false}.
\end{enumerate}
\end{definition}
%
The compile-time flag \code{T::Algorithm} selects which algorithm is
to be used.  Notice that this flag is taken as a hint only.  Should
one of the algorithms not be supported anymore in a future release,
the ``default'' algorithm will be chosen.  Here is the list of
supported algorithms and a short description of each:\par\medskip
\begin{center}
\begin{tabular}{|l|p{8.5cm}|}
\hline
Algorithm & Description \\
\hline
\hline
LP\_algorithm &
Runs the original LP-algorithm with maximal expected running time
$O(2^dn)$, independent of the order in which the balls are added. \\
\hline
Farthest\_first\_heuristic & A heuristic which seems to work fine
in practice.  There is
no guarantee on the running time, though.
\\
\hline
\hline
Default\_algorithm & This flag selects the one of the algorithms
above which we consider to be the ``best in general.''
Thank you for your confidence. \\
\hline
\end{tabular}
\end{center}\par\medskip
%
If \code{T::FT} is a floating-point type (i.e., \code{float} or
\code{double}), we say that \e{approximate computation} takes place;
in case \code{T::FT} is an exact number type, we speak of \e{exact
computation}.\footnote{As mentioned in the introduction, the term
``approximate'' might be missleading: It does not mean that only a
``small'' (but not necessarily minimal) enclosing ball is computed; it
simply means that rounding-errors might occur, thus rendering the
result ``inexact''.}
%
\begin{warning}
In the case of approximate computation we strongly encourage you to
use \code{Default\_algorithm} since it normally handles degeneracies
\e{much} better.  The numerical part of the test-suite runs using the
default algorithm only.
\end{warning}
%
Each of the above algorithms exists in two version, one suitable for
exact compution and one tuned for approximate computions, that is for
floating-point numbers of type \code{double} or \code{float}: In
approximate computation, the miniball will be computed using
floating-point arithmetic and hence its radius and coordinates might
be affected by rounding-errors.  On the other hand, the package will
compute the exact miniball when \code{T::FT} is an exact number
type.\par\medskip
%
Depending on the algorithm you select, many, many square-roots
computations have do be done on \code{float}s and
\code{double}s.\footnote{Even in the case when \code{T::FT} is an
  exact number type, the algorithm performs floating-point
  computations internally.}  Some processors are not very fast at
computing square-roots (for instance due to lacking hardware support
as on the PowerPC platform).  On such machines, it might pay out to
avoid square-roots and do the computation in some other way.  By
typedefing the compile-time flag \code{T::Use\_square\_roots} to
\code{Tag\_true} you can advise the algorithm to work with
square-roots; by setting it to \code{Tag\_false}, you tell it to
refrain from using them.\par\medskip
%
An example illustrating the concept of traits classes is given in
section~\ref{sect_example}.
%
\subsubsection{The interface of class \code{Min\_\-sphere\_\-of\_spheres\_d}}%
\label{sect_int_mini}
%
Let $T$ be a miniball traits class for balls of type~$B$ whose
dimension is~$d$.  Then an instance of class
\code{CGAL::Min\_sphere\_of\_spheres\_d\angl{T}} represents the
miniball of a set~$S$ of balls in the $d$-dimensional Euclidean
space.\footnote{The reasons why we have implemented a class
\code{Min\_sphere\_of\_spheres\_d} (and not a function) are: (i) The
class encapsulates more information about the miniball than just its
center and radius; for instance, you can iterate over the miniball's
support set.  (ii) Updating the miniball (i.e., recomputing the
miniball after adding some more balls) is more efficient since some
information from the previous calculation is kept internally and can
be reused.}
%
When default-constructed, an instance's set $S$ is empty, and
consequently its miniball is empty too, by definition.  To compute the
miniball of a set~$S$ of balls, you check in the balls by calling
\code{insert()}.  In order to query the miniball you can use the routines
\code{is\_empty()}, \code{radius()}, \code{center\_cartesian\_begin()},
\code{support\_begin()} and \code{discriminant()}.\par\medskip
%
%
For approximate computation the routines \code{radius()} and
\code{center\_cartesian\_begin()} produce \code{double}s or \code{float}s,
respectively.  However, in case you typedefed \code{T::FT} to some
exact number type, these routines cannot simply return numbers of type
\code{T::FT}, for the exact miniball might have irrational center
coordinates and radius.  Consequently, the routines \code{radius()}
and \code{center\_cartesian\_begin()} produce instances of type
\code{Min\_\-sphere\_\-of\_\-spheres\_d\angl{T}::Re\-sult}.
When the exact miniball is computed, this type is a
derived class of \code{std::pair\angl{\code{FT},\code{FT}}}: Denoting
the first component of a pair by~$a$ and its second by~$b$, an
instance of class \code{Result} then represents
the number~$a+b\sqrt{t}$.  Here, $t$ is the discriminant of the
miniball (see page~\pageref{disc}), which you obtain by calling
\code{discriminant()}.\par\medskip
%
Here are more detailed descriptions of the constructors, accessors and
predicates of class \code{Min\_sphere\_of\_spheres\_d\angl{T}}.
\begin{fdesclist}
%
\begin{fdescitem}{l}{Min\_sphere\_of\_spheres\_d(const T\& traits = T())}%
{$O(1)$}
Constructs an instance and sets the instance's set~$S$ to the empty
set.  Furthermore, it stores a reference to the given traits class
\code{traits} which it will use whenever it needs to access
coordinates or radii of balls.
\end{fdescitem}
%
%
\begin{fdescitem}{l@@{}l}{%
\multicolumn{2}{l}{template$\langle$typename InputIterator$\rangle$} \\
Min\_sphere\_of\_spheres\_d(&InputIterator begin,InputIterator end,\\
&const T\& traits = T())%
}{$O(n)$}
%
Works like the constructor above, but calls \code{insert(begin,end)}
in addition (which adds the $n$ balls in the range \code{[begin,end)}
to~$S$).
\end{fdescitem}
%
%
\begin{fdescitem}{l}{%
void insert(const Sphere\& b);}{$O(n)$}%
%
Adds the ball~\code{b} to the instance's set~$S$.\par
%
\emph{Note:} It is okay if some of the added balls are identical (i.e., if
the set $S$ is a multiset).
\end{fdescitem}
%
\begin{fdescitem}{l}{%
template$\langle$typename InputIterator$\rangle$\\
void insert(InputIterator begin,InputIterator end)}{$O(n)$}%
%
Adds the $n$ balls from the range \code{[begin,end)} to the instance's
set~$S$ by calling \code{insert(b)} for every ball~\code{b} in the
range.\par
%
\emph{Note:} It is okay if some of the added balls are identical (i.e., if
the set $S$ is a multiset).
\end{fdescitem}
%
\begin{fdescitem}{l}{void prepare(int n);}{$O(n)$}%
%
If you know the number $n$ of balls you want to compute the miniball
of, then it is a good idea to call \code{prepare(n)} before adding the
balls.  This will allocate enough resources to compute the ball
without reallocating memory.  Notice that the parameter $n$ denotes
the total number of balls you will have checked in (including the
balls you have already added).
\end{fdescitem}
%
\begin{fdescitem}{l}{void clear();}{$O(n)$}%
%
Removes all added balls, i.e., sets $S:= \emptyset$.
\end{fdescitem}
%
\begin{fdescitem}{l}{%
template$\langle$typename InputIterator$\rangle$\\
void set(InputIterator begin,InputIterator end)}{$O(n)$}%
%
Sets the set $S$ to the spheres in the given range.  More precisely,
this is identicaly to a call to \code{clear()}, followed by
\code{insert(begin,end)}.  Notice that the balls
in the given range must exist until this instance is destructed (see
discussion of routine \code{insert()} above).
\end{fdescitem}
%
\begin{fdescitem}{l}{bool is\_empty()}{$O(1)$}%
Returns true if and only if the set~$S$ is empty.
\end{fdescitem}
%
\begin{fdescitem}{l}{FT radius()}{$O(1)$}%
Returns the radius of the miniball.\par
%
\emph{Precondition:} \code{is\_empty()} returns false.
\end{fdescitem}
%
\begin{fdescitem}{l}{Cartesian\_const\_iterator center\_cartesian\_begin()}%
{$O(1)$}%
Returns an iterator (of type
\code{Min\_sphere\_of\_spheres\_d::Coordinate\_\-iterator}) to the
first of the $d$ Euclidean coordinates of the miniball's center.  The
value type of the returned iterator is
\code{Min\_\-sphere\_\-of\_\-spheres\_d\angl{T}::Result}, which
coincides with \code{double} or \code{float} for approximate
computation and which is a pair (as described above) otherwise.\par
%
\emph{Precondition:} \code{is\_empty()} returns false.
\end{fdescitem}
%
\begin{fdescitem}{l}{Cartesian\_const\_iterator center\_cartesian\_end()}%
{$O(1)$}%
returns \code{center\_cartesian\_begin()+d}, i.e., the corresponding
past-the-end iterator.
\end{fdescitem}
%
\begin{fdescitem}{l}{Support\_iterator support\_begin()}{$O(1)$}%
  Returns an iterator (of type
  \code{Min\_\-sphere\_\-of\_\-spheres\_d::Support\_iterator}) which
  you can use to iterate over a basis of~$S$.  Remember that a
  basis~$R$ of~$S$ is an inclusion-minimal subset of the pushed
  balls~$S$ with the property that $\MB(R)=\MB(S)$.  Furthermore, all
  balls in~$R$ touch the boundary of the miniball (i.e., are tangent
  to it) and $|R|\le d+1$.
\end{fdescitem}
%
\begin{fdescitem}{l}{Support\_iterator support\_end()}{$O(1)$}%
  Returns a past-the-end iterator (of type
  \code{Min\_\-sphere\_\-of\_\-spheres\_d::Support\_\-ite\-ra\-tor})
  pointing past the end of the basis returned by
  \code{support\_begin()}.
\end{fdescitem}
%
\begin{fdescitem}{l}{bool is\_valid()}{$O(n)$}%
  This routine asserts that the computed ball is indeed the miniball.
  More precisely, \code{is\_valid()} returns true if and only if the
  following three conditions are satisfied:
\begin{itemize}
\item All added balls are contained in the computed ball.
\item All support balls (i.e., the balls in the range returned by
\code{support\_begin()} and \code{support\_end()}) are on the boundary
of the computed ball.
\item The support balls span the miniball and no
support ball is redundant.
\end{itemize}
This routine should only be called for exact computation, for the
validity check itself is inexact otherwise.  (If \code{is\_valid()}
doesn't return \code{true} for an exactly computed miniball, then this
implementation is incorrect---\e{do} contact me in such a case!)
\end{fdescitem}
%
\end{fdesclist}
%
\subsection{An example}\label{sect_example}
%
This section presents a small, self-contained example.  It shows
how to write a traits class in order to use your own ball-type with
the package.
%
The example uses floating-point numbers; an example computing the
exact miniball is included in the package (it requires {\sc Cgal}
and/or the {\sc gnu mp} library to do the multi-precision
arithmetic).\par\medskip
%
So assume I have already written my own type \code{Ball}, which
looks as follows (and which is totally independent of package
\code{Min\_\-sphere\_\-of\_\-spheres\_d}):\par\medskip
%
@$@<sample sphere implementation@>==@{@-
class Ball {
private: // representation:
  double c[3]; // center in Eucliden coordinates
  double r;    // radius

public: // constructor:
  Ball() {}

  template<typename InputIterator>
  Ball(InputIterator from,double r) : r(r) {
    c[0] = *from;
    c[1] = *++from;
    c[2] = *++from;
  }

public: // accessors:
  double radius() const { return r; }

public: // iterator to iterate over the 3 coordinates:
  typedef const double *Coord_iterator;
  Coord_iterator begin_center() const { return c; }
};@}\par\medskip
%
Imagine now that I want to use the package
\code{Min\_\-sphere\_\-of\_\-spheres\_d} to compute the miniball of
some spheres, let's say of a million random spheres.  The first thing
I have to do is write a miniball traits class as described in
section~\ref{sect_traits}.  This traits class (which I called
\code{Ball\_traits} by an arbitrary decision) tells the package
\code{Min\_\-sphere\_\-of\_\-spheres\_d} how it can access the center
and the radius of balls of my type \code{Ball}:\par\medskip
%
@$@<sample traits class@>==@{@-
struct Ball_traits {
  typedef Ball Sphere;
  static const int D=3;
  typedef double FT;
  typedef CGAL::Default_algorithm Algorithm;
  typedef CGAL::Tag_false Use_square_roots;
  typedef Sphere::Coord_iterator Cartesian_const_iterator;

  static Cartesian_const_iterator
    center_cartesian_begin(const Ball& b) {
    return b.begin_center();
  }
  static double radius(const Ball& b) {
    return b.radius();
  }
};@}\par\medskip
%
For the sake of clarity, let's step through the above definition.  The
first line tells the package \code{Min\_\-sphere\_\-of\_\-spheres\_d}
that it will have to deal with balls of type \code{Ball}, while the
second line specifies that \code{Ball}s are 3-dimensional balls.
According to the next line, all radii and center coordinates are
\code{doubles}.  The definition of the type \code{Algorithm} causes
the compiler to generate code for the recommended default algorithm
using floating-point arithmetic; square-roots being avoided.  Finally,
the remainder of the traits class tells the package how it can access
the center coordinates and the radius of a given ball~$b$.  That's it!
We are now ready to use the package:\par\medskip
%
@$@<sample program@>==@{@-
double uniform() {  // a (platform independent) random number generator
  static int lastNo = 230575L;
  const int a = 16807L, m = 2147483647L, q = 127773L, r = 2836L;
  int gamma = a * (lastNo % q) - r * (lastNo / q);
  if (gamma > 0)
    lastNo = gamma;
  else
    lastNo = gamma + m;
  return static_cast<double>(lastNo)/m;
}

int main(int,char **) {
  typedef CGAL::Min_sphere_of_spheres_d<Ball_traits> Minsphere;
  using namespace std;

  // generate a million random spheres:
  const int N = 1000000;
  vector<Ball> S;
  for (int i=0; i<N; ++i) {
    double a[3] = { uniform(), uniform(), uniform() };
    S.push_back(Ball(a,uniform()));
  }

  // remember current time:
  clock_t time = clock();

  // check in the balls:
  Minsphere mb(S.begin(),S.end());

  // measure time:
  mb.is_empty();
  time = clock() - time;

  // output running time:
  cout << "----------------------------------------------------" << endl
       << "Benchmark: " << static_cast<double>(time)/CLOCKS_PER_SEC
       << "s (in units of " << 1.0/CLOCKS_PER_SEC << "s)." << endl
       << "----------------------------------------------------" << endl
       << endl;

  // output the radius:
  cout << "Done.  (Radius: " << mb.radius() << ')' << endl;
}@}\par\medskip
%
@O@<../examples/Min_sphere_of_spheres_d/benchmark.C@>==@{@-
@<header@>@(examples/Min_sphere_of_spheres_d/benchmark.C@)

#include <iostream>
#include <ctime>
#include <CGAL/Min_sphere_of_spheres_d.h>

@<sample sphere implementation@>

@<sample traits class@>

@<sample program@>
@}\par\medskip
%
%
\label{sectend_specification}
\pagebreak
\section{The implementation}
%
\begin{remark}
If you are only interested in using the package, then you do not have
to read this section---although you are welcome to do so, of course!
In particular, do not write code which relies on information provided
in the sequel, because everything in here may change in a future
release; please stick to the specification in
section~\ref{sect_specification}.
\end{remark}
%
We will implement two algorithms, the LP-algorithm as described
in~\cite{f-sebb-01,msw-sblp-92} and a heuristic which we call
``farthest-first.''  Both methods rely on the notions of \e{support
sets} and \e{basises}.  So let's briefly recall their meaning.
Please refer to~\cite{fg-sebbcsa-03,f-sebb-01} for the details.
%
\begin{definition}
Let $S$ be a set of balls.  A set $R\subseteq S$ is called a \e{support
set of~$S$} if $\MB(R)=\MB(S)$ and every ball in~$R$ touches the
boundary~$\partial\MB(R)$.
\end{definition}
%
Figure~\ref{fig_ss} shows some support sets and illustrates the
notion of a basis as defined below.  (Notice that the set~$R$ in the
middle example is not a basis, for removing the upper ball doesn't
cause the miniball to shrink.)
%
\begin{figure}[tbhp]
\begin{center}
{\renewcommand{\arraystretch}{1}
\begin{tabular}{c@@{\hspace*{1cm}}c@@{\hspace*{1cm}}c}
\includegraphics[clip]{figs/ss/basis.eps} &
\includegraphics[clip]{figs/ss/ss_basis.eps} &
\includegraphics[clip]{figs/ss/notbasis.eps} \\
a support set & a support set & not a support set \\
a basis & not a basis & not a basis
\end{tabular}
\renewcommand{\arraystretch}{1}}
\caption{\label{fig_ss}Three configurations and their (dashed) miniball.}
\end{center}
\end{figure}
%
\begin{definition}
A set~$R$ of balls is called a \e{basis} if no proper subset of~$R$
has a smaller miniball than~$\MB(R)$.  For a given set~$S$ of balls,
we say that $R\subseteq S$ is a \e{basis of~$S$} if $R$ by itself is a
basis and $\MB(R)=\MB(S)$.\note{\footnote{In the terminology
of~\cite{f-sebb-01}, a basis is the same as a minimal support set.}}
\end{definition}
%
\label{min_ss}%
Notice that every basis of~$S$ is a support set of~$S$, but that the
converse is not necessarily true.  Still, if we know that $R$ is a
support set of~$S$ such that every proper subset of~$R$ spans a
smaller miniball, then $R$ has to be a basis, obviously.\par\medskip
%
We will also make use of the fact that the centers of a basis are
affinely independent~\cite[theorem~6]{f-sebb-01} and that a basis
consists of at most~$d+1$ balls~\cite[theorem~4]{f-sebb-01}.
Furthermore, we need the following lemma taken from~\cite{f-sebb-01}.
%
\begin{lemma}\label{lemma_seidel}
Let $B$ be a ball having the balls~$R=\{B_1,\ldots,B_n\}$ on its
boundary.  Then $B=\MB(R)$ if and only if $c_B$ is a convex
combination of the centers~$c_i$.
\end{lemma}
%
In the following, we denote by $\ex_B(B'):= \|c_B-c_{B'}\|+\rho_{B'}$ the
\e{excess} of ball~$B'$ with respect to ball~$B$.  Notice that ball
$B'$ is contained in~$B$ if and only if $\ex_B(B')\le
\rho_B$.\par\medskip
%
The rest of this document is structured as follows.  We first provide
the heavily used primtives \code{contains()} and
\code{find\_farthest()}, and discuss the type
\code{Result} used to represent the radius and the
coordinates of the exact miniball.  Next comes the abstract data type
\code{Support\_set} which is used to compute the coordinates and the
radius of the miniball, once a basis is given.  Then we use this data
type to provide an implementation of the routine \code{pivot($C$,$D$)}
which computes, given a basis~$C$ and a ball~$D$ not contained in the
miniball~$\MB(C)$, a basis of~$C\cup\{D\}$.  With these primitives at
hand, we will then be able to formulate the mentioned LP-algorithm and
heuristic.
%
\subsection{The type \code{Result}}
%
As has been mentioned in the introduction, the radius and the center
coordinates of the miniball can all be represented as
$a_i+b_i\sqrt{d}$, where $d$ is some positive number called the
discriminant.  During exact computation we will consequently represent
radii and coordinates as pairs~$(a_i,b_i)\in\Q^2$ and store them in
instances of class \code{Pair\angl{\code{FT}}} discussed below; the
number~$d$ is stored just once.  During approximate computation we
will store the numbers $a_i+b_i\sqrt{d}$ as machine floating-point
numbers.  The following template takes a number type and returns a
structure whose type \code{Result} is either
\code{Pair\angl{\code{FT}}} in case we do the exact computation, or
which coincides with \code{FT} otherwise.\par\medskip
%
%
@$@<type-selector for type Result@>==@{@-
template<typename FT>
struct Selector {
  typedef Pair<FT> Result;
  typedef Tag_true Is_exact;
};

template<>
struct Selector<float> {
  typedef float Result;
  typedef Tag_false Is_exact;
};

template<>
struct Selector<double> {
  typedef double Result;
  typedef Tag_false Is_exact;
};@}\par\medskip%
%
The class \code{Pair\angl{T}} is a \code{std::pair\angl{T,T}} with
some additional routines which allow us (at least in some cases) to
treat \code{Pair}s just like floating-point numbers:\par\medskip
%
@$@<definition of class Pair@>+=@{@-
template<typename FT>
class Pair : public std::pair<FT,FT> {
private:
  typedef std::pair<FT,FT> Base;

public: // construction:
  Pair() : Base() {}

  Pair(const FT& a,const FT& b) : Base(a,b) {}

  Pair(int i) : Base(i,0) {}

  Pair& operator=(const FT& x) {
    this->first  = x;
    this->second = 0;
    return *this;
  }

public:  // arithmetic and comparision:
  inline Pair operator+(const Pair& a) const {
    return Pair(this->first+a.first,this->second+a.second);
  }

  inline Pair operator-(const Pair& a) const {
    return Pair(this->first-a.first,this->second-a.second);
  }

  inline Pair operator-(const FT& a) const {
    return Pair(this->first-a,this->second);
  }

  inline Pair operator*(const FT& a) const {
    return Pair(this->first*a,this->second*a);
  }

  inline Pair operator/(const FT& a) const {
    CGAL_MINIBALL_ASSERT(a != FT(0));
    return Pair(this->first/a,this->second/a);
  }

  inline Pair& operator+=(const Pair& p) {
    this->first  += p.first;
    this->second += p.second;
    return *this;
  }

  inline Pair& operator-=(const Pair& p) {
    this->first  -= p.first;
    this->second -= p.second;
    return *this;
  }

  inline bool operator!=(const Pair& p) const {
    return this->first!=p.first || this->second!=p.second;
  }
};

template<typename FT>
inline Pair<FT> operator+(const FT& a,const Pair<FT>& p) {
  return Pair<FT>(a+p.first,p.second);
}

template<typename FT>
inline Pair<FT> operator-(const FT& a,const Pair<FT>& p) {
  return Pair<FT>(a-p.first,-p.second);
}

@}\par\medskip%
%
The only additonal predicate we need is the test for negativity.  The
following routine \code{is\_neg()} returns true if and only if
$a+b\sqrt{d}<0$.)\par\medskip
%
@$@<definition of class Pair@>+=@{@-
template<typename FT>
inline bool is_neg(const FT& p,const FT&) {
  return p < 0;
}

template<typename FT>
inline bool is_neg(const Pair<FT> p,const FT& d) {
  const bool aneg = p.first<FT(0), bneg = p.second<FT(0);

  if (aneg && bneg)
    return true;
  if (!aneg && !bneg)
    return false;

  // So what remains are the cases (i) a<0,b>=0 and (ii) a>=0,b<0:
  //   (i)  We need to test b*sqrt(d)<-a with b,-a>=0.
  //   (ii) We need to test a<(-b)*sqrt(d) with a,-b>=0.
  // Hence:
  const FT x = sqr(p.second)*d, y = sqr(p.first);
  return aneg? x<y : y<x;
}

template<typename FT>
inline bool is_zero(const Pair<FT> p,const FT& d) {
  if (d != FT(0))
    // check whether the sides of a=-b*sqrt(d) (*)
    // have different signs:
    if ((p.first>FT(0)) ^ (p.second<FT(0)))
      return false;

  // Here we have either:
  //   (i)   d=0, or
  //   (ii)  a>0,b<0,d!=0, or
  //   (iii) a<=0,b>=0,d!=0
  // Hence both sides of (*) are either positive or negative.
  return sqr(p.first) == sqr(p.second)*d;
}

template<typename FT>
inline bool is_neg_or_zero(const FT& p,const FT& d) {
  return p <= 0;
}

template<typename FT>
inline bool is_neg_or_zero(const Pair<FT> p,const FT& d) {
  return is_neg(p,d) || is_zero(p,d);
}@}\par\medskip%
%
In order to be able to treat \code{Pair}s and floating-point numbers
similarly, we have added ``dummy'' routines \code{is\_neg()} and
\code{is\_neg\_or\_zero()} for ordinary numbers.
%
\subsection{The containment test}
%
In this section we develop the containment test, that is a routine
\code{contains()} which checks whether a certain ball~$B'$ is
contained in another ball~$B$.  We will implement \code{contains()} as
a method of the class \code{Support\_set}, which is worked out in the
next section.  The ball~$B$ is then given implicitly by the instance
variables of the class: There is an integer variable \code{m} such
that the array \code{center} holds the center and \code{sol[m]} holds
the radius of~$B$.
%
In case of exact computation, there is also a variable
\code{discrim[m]} available, containing the discriminant of the
ball~$B$; as discussed earlier, the variables in \code{center} and
\code{sol[m]} are instances of class
\code{Pair\angl{\code{FT}}} then.
%
The ball~$B'$ is passed as an argument to routine
\code{contains()}.\par\medskip
%
%
Let's start with the containment test used for approximate computation.
%
Due to inexact floating-point numbers we cannot expect to find the
exact miniball.  What we aim at instead is a ``miniball''~$B$ which
encloses all given balls with good ``relative error.''  This shall
mean that the ball~$B^\star$ with center $c_B$ and radius
$\rho^\star=(1+\varepsilon)\,\rho_B$ (for some small $\varepsilon>0$)
contains all given balls.\par\medskip
%
The following routine checks whether $B$ (with center \code{center}
and radius \code{sol[m]}) contains the ball~$B'$ (specified by
\code{c} and \code{r}) with relative error $\varepsilon=\code{tol}-1$.
For this, we multiply \code{r} by \code{tol} and then check whether
$B'\subseteq B$ in floating-point arithmetic.\par\medskip
%
%In order to save some
%time we don't do the multiplication
%$\code{r}\cdot\code{tol}$ every time, but we precompute it and store
%the result in the instance variable \code{scaledSol}.  So whenever we
%call \code{contains()}, we must make sure that \code{prescale()} has
%been called before.  This optimization is worth the effort since
%contains is called very, very often.\par\medskip
%
@!@$@<prescaling for routine contains()@>==@{@-
@!FT scaledSol;
@!
@!inline void prescale() {
@!  scaledSol = sol[k] *
%
@$@<useful functors@>+=@{@-
template<typename FT>
struct Subtract_and_square {
  inline FT operator()(const FT x,const FT y) const {
    return sqr(x-y);
  }
};
@}\par\medskip
%
@$@<routine contains()@>+=@{@-
template<typename InputIterator>
bool contains(InputIterator c,const FT& r,
              const FT tol,
              const Tag_false is_exact) const {
  // scale ball:
  const FT r1 = sol[m]*tol;

  // check radii:
  if (r > r1)
    return false;

  // compute the (squared) distance from center to c:
  const FT dist = inner_product_n<D>(center,c,
    FT(0),std::plus<FT>(),Subtract_and_square<FT>());

  // check containment:
  return dist <= sqr(r1-r);
}
@}%
%
\par\medskip
%
When we do the exact computation, we proceed in a similar fashion.
Here however, the coordinates \code{center} are numbers of type
\code{Pair\angl{\code{FT}}}.  Consequently, the squared distance
from \code{center} to~\code{c} is a sum of squares of expressions of the
form $(a+b\sqrt{\code{discrim}})-e$ (that is, an algebraic coordinate of the
center of ball~$B$ minus a rational coordinate~$e$ of the center of
ball~$B'$).  Since
\[ \left(a-e+b\sqrt{\code{discrim}}\right)^2 =
\left(t^2+b^2\code{discrim}\right) + 2tb\sqrt{\code{discrim}}
\qquad \mbox{where} \qquad t= a-e,
\]
we can handle this in \code{Subtract\_and\_square\_Pair<FT>} by keeping
a reference to the discriminant.  Here is the resulting code
fragment:\par\medskip
%
@$@<useful functors@>+=@{@-

template<typename FT>
class Subtract_and_square_pair {
private:
  const FT& d;

public:
  Subtract_and_square_pair(const FT& d) : d(d) {}

  inline Pair<FT> operator()(const Pair<FT>& x,
                                 const FT& y) const {
    const FT t = x.first - y;
    return Pair<FT>(sqr(t)+sqr(x.second)*d,FT(2)*t*x.second);
  }
};
@}\par\medskip
%
@$@<routine contains()@>+=@{@-

template<typename InputIterator>
bool contains(InputIterator c,const FT& r,
              const double,const Tag_true is_exact) const {
  typedef Pair<FT> P;

  // check radii:
  const P rd = sol[m]-r;
  if (is_neg(rd,discrim[m]))
    return false;

  // compute the (squared) distance from center to c:
  const P dist = inner_product_n<D>(center,c,
    P(0,0),std::plus<P>(),Subtract_and_square_pair<FT>(discrim[m]));

  // compute the square of rd:
  const P sqrRd(sqr(rd.first)+sqr(rd.second)*discrim[m],
                FT(2)*rd.first*rd.second);

  // check containment:
  return is_neg_or_zero(dist-sqrRd,discrim[m]);
}
@}
%
\subsection{The routine \code{find\_farthest()}}
%
For the formulation of the farthest-first heuristic we need a method
to finds us in a given range $[\code{from},\code{to})$ of the list
\code{l} the one ball with maximal excess with respect to the ball
stored in~\code{ss}.
%
% (Again, we want to do this up to a relative error of
% $\varepsilon=1-\code{tol}$%
%
%# .)
%## , at least for approximate computation.)
%
The routine \code{find\_farthest()} we are going to develop returns true
if and only if a ball~\code{l[i]} not contained in~\code{ss} is found;
the ball~\code{l[i]} will then be the one with largest
excess.\par\medskip
%
Although it is possible to give an exact implementation of
\code{find\_farthest()}, we will not do so.  The reasons for this
are that (i)~computing the ball with largest excess is rather
expensive (since we would have to deal with square-roots, at least
implicitly) and (ii)~that we do not really need an exact result:
All we are intersted in is a ball lying far away.  Consequently, we
can perform this ``pricing scheme'' in floating-point arithmetic,
even when \code{T::FT} is an exact number type.  In this case,
\code{find\_farthest()} \e{tries} to find the ball with largest
excess and returns whether the found ball is, under exact
arithmetic, contained in \code{ss}.  Thus it might happen that
there exists a ball not contained in \code{ss}, but that
\code{find\_farthest()} fails to find it, returning false
instead.\par\medskip
%
Here is the routine for approximate arithmetic.\par\medskip
%
@$@<routine find_farthest() with sqrt@>+=@{@-
template<class Traits>
bool Min_sphere_of_spheres_d<Traits>::find_farthest(int from,int to,
  int& i,const Tag_true use_sqrt,const Tag_false is_exact) {
  using namespace Min_sphere_of_spheres_d_impl;

  // we will compute the excesses w.r.t. to the ball B with
  // center ss.begin() and radius radius:
  const FT radius = ss.radius() * Tol;

  // find ball with largest excess:
  FT maximum = radius;
  for (int k=from; k<to; ++k) {
    // compute the (squared) distance from c1 to c2:
    const FT dist = inner_product_n<D>(ss.begin(),
      t.center_cartesian_begin(*l[k]),0.0,std::plus<FT>(),
      Subtract_and_square<FT>());

    // compute excess:
    using std::sqrt;
    const FT ex = sqrt(dist)+t.radius(*l[k]);

    // compare with current maximum:
    if (ex > maximum) { // (*)
      maximum = ex;
      i = k;
    }
  }

  // return whether B doesn't contain the ball l[i]:
  return maximum > radius;
}
@}\par\medskip
%
The version for exact arithmetic works as described above.  For
efficiency, we convert the radius and the center coordinates of the
ball \code{ss} (which are pairs of rationals) to floating-point
numbers first.\par\medskip
%
@$@<useful functors@>+=@{@-

template<typename FT>
struct Pair_to_double {
  const double root;

  Pair_to_double(const FT& disc) :
    root(std::sqrt(CGAL_MINIBALL_NTS to_double(disc))) {}

  inline double operator()(const Pair<FT>& p) const {
    return CGAL_MINIBALL_NTS to_double(p.first) +
           CGAL_MINIBALL_NTS to_double(p.second) * root;
  }
};

template<typename FT>
struct Subtract_and_square_to_double {
  inline double operator()(const double x,const FT& y) const {
    return sqr(x - CGAL_MINIBALL_NTS to_double(y));
  }
};
@}\par\medskip%
%
@$@<routine find_farthest() with sqrt@>+=@{@-

template<class Traits>
bool Min_sphere_of_spheres_d<Traits>::find_farthest(int from,int to,
  int& i,const Tag_true use_sqrt,const Tag_true is_exact) {
  using namespace Min_sphere_of_spheres_d_impl;

  // we will compute the excesses w.r.t. to the ball B with
  // center center and radius radius:
  Pair_to_double<FT> cast(ss.disc());
  const double radius = cast(ss.radius());
  double center[D];
  std::transform(ss.begin(),ss.begin()+D,center,cast);

  // find ball with largest excess:
  double maximum = radius;
  for (int k=from; k<to; ++k) {
    // compute the (squared) distance from c1 to c2:
    const double dist = inner_product_n<D>(center,
       t.center_cartesian_begin(*l[k]),0.0,std::plus<double>(),
       Subtract_and_square_to_double<FT>());

    // compute excess:
    using std::sqrt;
    const double ex = sqrt(dist) +
       CGAL_MINIBALL_NTS to_double(t.radius(*l[k]));

    // compare with current maximum:
    if (ex > maximum) { // (*)
      maximum = ex;
      i = k;
    }
  }

  // return whether B doesn't contain the ball l[i]:
  return maximum > radius &&
         !ss.contains(t.center_cartesian_begin(*l[i]),
                      t.radius(*l[i]),Tol,Is_exact());
}
@}\par\medskip
%
Computing the excess according to its definition as in the above
routines might not be the best way on some machines because the
formula contains a square-root (and some processors have very slow
square-root implementations).  Thus we provide another implementation
which computes the excess implicitly.
%
Observing that the excess is some number of the form $a+\sqrt{b}$ for
two floating-point numbers $a,b\ge 0$, we store it as the
pair~$(a,b)$.  In order to determine, at line~($\star$) above, whether
the current maximum $E=a+\sqrt{b}$ is strictly smaller the computed
excess $E'=a'+\sqrt{b'}$, we need to evaluate the boolean expression
$E'>E$.  Notice that
\begin{eqnarray}
E'>E &\Leftrightarrow& \sqrt{b'}-(a-a') >\sqrt{b} \nonumber \\
&\stackrel{\mathrm{(a)}}{\Leftrightarrow}& b'-2 (a-a')\sqrt{b'} +
(a-a')^2 > b \nonumber \\ &\Leftrightarrow& 2 (a-a')\sqrt{b'} <
(a-a')^2-(b-b') \label{firstsqr}
\end{eqnarray}
Here, equivalence (a) holds if $\sqrt{b'}-(a-a')\ge 0$, which is
equivalent to $b'\ge(a-a')^2$ provided $a-a'\ge 0$.  If $a-a'\ge 0$
and $(a-a')^2 -(b-b')>0$ then (\ref{firstsqr}) is equivalent to
\begin{equation}\label{secsqr}
4 (a-a')^2 b' < \left((a-a')^2-(b-b')\right)^2.
\end{equation}
If $a-a'\le 0$ and $(a-a')^2 -(b-b')\le 0$ then (\ref{firstsqr}) is
equivalent to
\begin{equation}\label{thirdsqr}
4 (a-a')^2 b' > \left((a-a')^2-(b-b')\right)^2.
\end{equation}
Altoghether we get the following code for the test $E'>E$:\par\medskip
%
%% IN THE FOLLOWING, EQUATION NUMBERS HAVE BEEN INSERTED MANUALLY.
@$@<routine compare()@>==@{@-
template<typename FT>
inline bool compare(const FT& a,const FT& b,
                    const FT& ap,const FT& bp) {
  const FT u = a-ap, uu = u*u;
  if (u >= FT(0)) {
    if (bp <= uu)
      return false;

    // here (1) holds
    const FT v = uu-b+bp;
    if (v <= 0)
      return false;

    // here (2) holds
    return 4 * uu * bp < sqr(v);
  } else {
    // here (1) holds
    const FT v = uu-b+bp;
    if (v >= FT(0))
      return true;

    // here (3) holds
    return 4 * uu *bp > sqr(v);
  }
}@}\par\medskip%
%
With this method at hand we can avoid square-root operations
entirely:\par\medskip
%
@$@<routine find_farthest() without sqrt@>+=@{@-
template<class Traits>
bool Min_sphere_of_spheres_d<Traits>::find_farthest(int from,int to,
  int& i,const Tag_false use_sqrt,const Tag_false is_exact) {
  using namespace Min_sphere_of_spheres_d_impl;

  // we will compute the excesses w.r.t. to the ball with
  // center ss.begin() and radius radius:
  const FT radius = ss.radius() * Tol;

  // find ball with largest excess:
  bool found = false;
  FT max = radius, maxp = 0;
  for (int k=from; k<to; ++k) {
    // compute the (squared) distance from c1 to c2:
    const FT dist = inner_product_n<D>(ss.begin(),
      t.center_cartesian_begin(*l[k]),0.0,std::plus<FT>(),
      Subtract_and_square<FT>());

    if (compare(max,maxp,t.radius(*l[k]),dist)) {
      max   = t.radius(*l[k]);
      maxp  = dist;
      i     = k;
      found = true;
    }
  }

  // return whether B doesn't contain the ball l[i]:
  return found;
}

template<class Traits>
bool Min_sphere_of_spheres_d<Traits>::find_farthest(int from,int to,
  int& i,const Tag_false use_sqrt,const Tag_true is_exact) {
  using namespace Min_sphere_of_spheres_d_impl;

  // we will compute the excesses w.r.t. to the ball B with
  // center center and radius radius:
  Pair_to_double<FT> cast(ss.disc());
  const double radius = cast(ss.radius());
  double center[D];
  std::transform(ss.begin(),ss.begin()+D,center,cast);

  // find ball with largest excess:
  bool found = false;
  double max = radius, maxp = 0;
  for (int k=from; k<to; ++k) {
    // compute the (squared) distance from c1 to c2:
    const double dist = inner_product_n<D>(center,
       t.center_cartesian_begin(*l[k]),0.0,std::plus<double>(),
       Subtract_and_square_to_double<FT>());

    const double r = CGAL_MINIBALL_NTS to_double(t.radius(*l[k]));
    if (compare(max,maxp,r,dist)) {
      max   = r;
      maxp  = dist;
      i     = k;
      found = true;
    }
  }

  // return whether B doesn't contain the ball l[i]:
  return found &&
         !ss.contains(t.center_cartesian_begin(*l[i]),
                      t.radius(*l[i]),Tol,Is_exact());
}
@}
%
%
\subsection{The type \code{Support\_set}}
%
In this section we implement the following primitive operation (which
we need in order to implement the routine \code{pivot($C$,$D$)}
discussed later).\par\medskip
%
\begin{quote}
{\bf Primitive.} Given a set~$R$ of at most $d+1$ balls, compute the
center and radius of~$\MB(R)$ at least when $R$ constitutes a basis,
or signal ``no'' otherwise.
\end{quote}
%
For the sake of clarity, let me say this in other words. \e{If}~$R$ is
a basis, then the primitive \e{has} to compute the center and radius
of~$\MB(R)$.  If $R$ is \e{not} a basis, then the primitive is allowed
to signal ``no'' (even though it is free to do the computation
anyway).\par\medskip
%
We will implement the primitive as a class \code{Support\_set} in the
following way.  An instance of class \code{Support\_set} has a stack~$R$
asscociated with it which is empty when the instance is initially
constructed or when it is \code{reset()}.  To change the set~$R$,
there are two routines.  The method \code{push(B)} adds the ball~$B$
to~$R$, and the routine \code{pop()} removes the ball pushed most
recently.  While \code{pop()} always works (provided
$R\not=\emptyset$), \code{push(B)} doesn't always succeed: If at the
time of \code{push(B)} it is already clear that $R\cup\{B\}$ cannot be
part of a basis (that is, if there doesn't exist any basis containing
$R\cup\{B\}$), then \code{push(B)} refuses to add the ball $B$ and
signals this to the caller by returning \code{false}.
%
Once you have pushed as many balls as you want, you can call
\code{is\_spanning()} to check whether the balls~$R$ constitute a
support set of~$R$ (which as such doesn't yet imply that $R$ forms a
basis).  Once you have successfully called \code{is\_spanning()}, you
can query the radius and the center coordinates using the methods
\code{radius()}, \code{center\_cartesian\_begin()} and
\code{disc()}.\par\medskip
%
As will become clear in section~\ref{sec:pivot} where we use class
\code{Support\_set} to implement the routine \code{pivot($C$,$D$)},
\code{is\_spanning()} will only be called when \code{push()} has been
invoked right beforehand (with no intermediate \code{pop()}).---We
will make use of this fact at some point in the implementation of
class \code{Support\_set}.\par\medskip
%
The class looks as follows:\par\medskip
%
@$@<definition of class Support_set@>==@{@-
template<class Traits>
class Support_set {
private: // some short hands:
  typedef typename Traits::FT FT;
  typedef typename Selector<FT>::Result Result;
  typedef typename Selector<FT>::Is_exact Is_exact;
  typedef typename Traits::Use_square_roots Use_sqrt;
  typedef typename Traits::Sphere Sphere;
  static const int D = Traits::D;
  typedef typename Traits::Cartesian_const_iterator CIt;

public: // constructor:
  inline Support_set(Traits& traits);

public: // access:
  inline const Result& radius() const;
  inline const Result *begin() const;
  inline const FT& disc() const;

public: // containment test:
  @<routine contains()@>

public: // modification:
  void reset();
  bool push(const Sphere& ball);
  inline void pop();
  bool is_spanning();

private: // utility:
  inline bool find_radius(const Tag_false is_exact);
  inline bool find_radius(const Tag_true is_exact);

private: // traits class:
  Traits& t;

private: // for internal consisteny checks:
  #ifdef CGAL_MINIBALL_DEBUG
  // The following variable is true if and only if no ball has been
  // pushed so far, or is_spanning() has been called at least once and
  // neither pop() nor push() have been called since last is_spanning().
  bool is_spanning_was_called;
  #endif

private: // member fields:
  @<member fields of class Support_set@>
};
@}\par\medskip
%
Before we can give the code for the class's routines, we need to
derive the formulas for the primitive.
%
\subsubsection{A closed formula for the primitve}
%
Let~$R=\{B_0,\ldots,B_{m-1}\}$ denote the primitive's input, that is
an arbitrary set of at most~$d+1$ balls in~$\R^d$.  We are supposed to
compute $\MB(R)$ when $R$ is a basis of $\MB(R)$.  Notice that when
$R$ \e{is} a basis, the balls $R$ are tangent to $\MB(R)$, and hence
we have $\MB(R)=\MBR(\emptyset,R)$.  Therefore, we will actually
``try'' to compute $\MBR(\emptyset,R)$ and will guarantee that this
works, provided $R$ is a basis of~$\MB(R)$.  More precisely, our plot
for the primitive is to compute the balls containing~$R$ on the
boundary, select the smallest one among them (which coincides with
$\MBR(\emptyset,R)$ then) and check whether its center is a convex
combination of the centers of~$R$.  Should this latter test turn out
positive, then we know by Lemma~\ref{lemma_seidel} that the ball in
question is the miniball of~$R$ and so we output it.  If on the other hand
the test fails, then the ball can't be the miniball and we signal
``no.''\par\medskip
%
Instead of searching for balls containing~$R$ on their boundary, we
look for the larger class of balls which the balls in~$R$ are tangent
to; this will be easier to wrap into formulas.  However, there are in
general infinitely many balls being tangent to the balls~$R$, and we
do not want to compute them all.  But recall that the center
of~$\MB(R)$ is a convex, in particular an affine combination of the
centers of~$R$.  So we will restrict our search for balls tangent
to~$R$ to those balls~$T(R)$ whose centers lie in the affine hull of
the centers of~$R$:
%
\begin{definition}
For a finite set~$R$ of balls, let $T(R)$ be the set of balls~$B$
whose centers lie in the affine hull of the centers of the balls~$R$
and for which $\|c_B-c_{B'}\|^2 = (\rho_B-\rho_{B'})^2$ holds for all
balls~$B'\in R$.
\end{definition}
%
(The relation between the set $T(R)$ and $\MBR(\emptyset,R)$ will be
discussed later on, see Lemma~\ref{lemma_constr}.)\par\medskip
%
{\bf Some notation.}\label{notation}
%
%For the rest of this section we
% %
% set $B = \MB(R)$ and as usual $c_B$ and~$\rho_B$ denote the center and
% radius of~$B$, respectively.  Furthermore, we write $z_B$
% and~$\delta_B$ for the center and radius, respectively,
% of~$\MBR(\emptyset,\{c_0,\ldots,c_{n-1}\})$, that is, of the smallest
% enclosing ball containing the \e{points}~$c_i$ on its boundary.  Also,
% we
% %
We denote the center and radius of the ball~$B_i$ by $c_i$
and~$\rho_i$, respectively.  Furthermore we use capital variables to
denote subtraction by~$c_0$: we have $C_i:= c_i - c_0$, $C_B:= c_B -
c_0$ and so on.  For $k\ge 1$ we define
%
\[
Q_k := [ C_1\,\cdots\,C_k ]
%\left[ \begin{array}{ccc}C_1 & \cdots & C_k\end{array} \right]
\qquad
A_k :=
%\left[
%\begin{array}{ccc}
%2 C_1^T C_1 & \cdots & 2 C_1^T C_k     \\
%\vdots      &        & \vdots              \\
%2 C_k^T C_1 & \cdots & 2 C_k^T C_k \\
%\end{array}
%\right] =
2 Q_k^T Q_k
\qquad
%
M_k := 2 Q_k A_k^{-1} Q_k^T
\]
and
\[
v_k := \left[
\begin{array}{c}
C_1^T C_1         \\
\vdots            \\
C_k^T C_k         \\
\end{array}
\right]
%
\quad
w_k := \left[
\begin{array}{c}
\rho_0^2 - \rho_1^2     \\
\vdots                  \\
\rho_0^2 - \rho_k^2 \\
\end{array}
\right]
%
\quad
r_k := 2\,\left[
\begin{array}{c}
\rho_1 - \rho_0     \\
\vdots              \\
\rho_k - \rho_0 \\
\end{array}
\right]
\]
\[
d_k:= Q_k A_k^{-1} v_k \qquad e_k:= Q_k A_k^{-1} w_k \qquad f_k:= Q_k A_k^{-1} r_k
\]
Finally we introduce for $k\ge 2$ the quantities\label{defs}
\[
\alpha_k:= 2 C_k^T C_k - 2 C_k^T M_{k-1} C_k
\]\[
\delta_k:= (C_k-d_{k-1})^T (C_k-d_{k-1}) - d_{k-1}^T d_{k-1}
\]
\[
\epsilon_k:= \rho_0^2 - \rho_k^2 - 2 C_k^T e_{k-1}
\qquad
\phi_k:= 2\,(\rho_k - \rho_0) -  2C_k^T f_{k-1}
\]
(It is understood that some of these quantities are only defined for
regular~$A_k$.)
%
\begin{lemma}\label{lemma_Q}
Let $R=\{B_0,\ldots,B_{m-1}\}$ be a set of $2\le m\le d+1$ balls
in~$\R^d$.  Then $A_{m-1}$ is regular if and only if the centers of
the balls~$R$ are affinely independent.
\end{lemma}
%
\begin{proof}
The matrix~$A_{m-1}$ has the property that $a^T A_{m-1} a =
2\,\|\sum_{i=1}^{m-1} a_i C_i\|^2$ for all vectors $a\in\R^{m-1}$.
Furthermore, our centers~$c_i$ are affinely independent if and only if
the vectors~$C_i$ are linearly independent.  The~$C_i$'s on their part
are linearly independent if and only if $\sum_{i=1}^{m-1} a_i C_i
\not= 0$ for all vectors~$a\not=0$.  Finally, $\sum_{i=1}^{m-1} a_i
C_i \not= 0$ for all vectors~$a\not=0$ if and only if $a^T A_{m-1}
a\not=0$ for all vectors~$a\not=0$ because of the above observation.
\end{proof}
%
%
\begin{lemma}\label{lemma_TR}
Let~$R=\{B_0,\ldots,B_{m-1}\}$ be a set of~$2\le m\le d+1$ balls and
consider
\begin{eqnarray}
A_{m-1} x &=& v_{m-1} + w_{m-1} + \rho r_{m-1}     \label{b_lin}  \\
\frac{1}{2}\,x^T A_{m-1} x &=& (\rho-\rho_0)^2 \label{b_quad}
\end{eqnarray}
Then $D\in T(R)$ if and only if $C_D = Q_{m-1} x$ and $\rho_D=\rho$
where $(x,\rho)$ is a so\-lu\-tion of the system
(\ref{b_lin}--\ref{b_quad}).\note{\footnote{It can happen that the
equation~(\ref{b_quad}) has strictly negative discriminant so that
$T(R)=\emptyset$ (we don't count complex balls): Take for instance the
balls $R=\{(0,0,100),(-10,10,1),(0,102,1)\}$ in the plane.  Notice
that this implies that the following statement (holding for points) is
\e{not} true in general: Given $d+1$ balls with affinely independent
centers, there exists at least one tangent ball.}}
\end{lemma}
%
\begin{proof}
$(\Rightarrow)$ By definition of~$T(R)$, the center of~$D$ can be
written as an affine combination $c_D = \sum_{i=0}^{m-1}x_i c_i$ where
$\sum_{i=0}^{m-1} x_i = 1$.  To derive the equations in the claim, we
write out the $m$ conditions $\|c_D-c_k\|^2=(\rho_D-\rho_k)^2$.  Using
$C_D=c_D-c_0$ these read
\begin{eqnarray}
C_D^T C_D &=& (\rho_D-\rho_0)^2 \label{first_constr} \\
(C_k-C_D)^T (C_k-C_D) &=& (\rho_D-\rho_k)^2 \qquad (1\le k\le m-1).
\end{eqnarray}
Subtracting the latter from the former equation yields
\begin{equation}\label{diff_case_d}
2\,C_k^T C_D - C_k^T C_k = 2 \rho_D \, (\rho_k-\rho_0) + \rho_0^2 - \rho_k^2
\qquad (1\le k\le m-1).
\end{equation}
Furthermore we have $C_D = c_D - c_0 = \sum_{i=0}^{m-1} x_i\,(c_i-c_0)
= \sum_{i=1}^{m-1} x_i C_i = Q_{m-1}x$.  Substituting this formula
for~$C_D$ back into~(\ref{diff_case_d}) results in the following~$m-1$
linear equations
\begin{equation}\label{deriv_linsys}
2 C_k^T Q_{m-1} x =
% \sum_{i=1}^{m-1}\,2\,C_k^T C_i x_i =
C_k^T C_k + \rho_0^2 - \rho_k^2  + 2\rho_D\,(\rho_k-\rho_0)
\quad (1\le k\le m-1),
\end{equation}
which, when written in matrix notation, give~(\ref{b_lin}) as desired.
Furthermore, the first constraint~(\ref{first_constr}) can be written
as $(\rho_D-\rho_k)^2=C_D^T C_D = 1/2\,x^T A_{m-1} x$.\par\medskip
%
$(\Leftarrow)$ The linear system~(\ref{b_lin}) is equivalent
to~(\ref{deriv_linsys}), and with $C_D = Q_{m-1}x$ the second
equation~(\ref{b_quad}) is simply the first
constraint~(\ref{first_constr}).  Adding the latter equation
to~(\ref{deriv_linsys}) results in the original
constraints~$\|c_D-c_k\|^2=(\rho_D-\rho_k)^2$, as desired.  Also, we
can set $x_0:= 1 -\sum_{i=1}^{m-1} x_i$, allowing us to write
\begin{equation}\label{affine_comb}
c_D = C_D+c_0 = \sum_{i=0}^{m-1} x_i\,(c_i-c_0) + c_0 =
\sum_{i=0}^{m-1} x_i c_i.
\end{equation}
So we see that $c_D$ is an affine combination of
the centers of the balls in~$R$.
\end{proof}
%
The relation between the set $T(R)$ and $\MBR(\emptyset,R)$ is as follows.
%
\begin{lemma}\label{lemma_constr}
Let $R$ be a set of $m=|R|\ge 2$ balls with affinely independent
centers $C=\descset{c_B}{$B\in R$}$.  Assume $\MBR(\emptyset,R)$
exists and that its center lies in $\aff(C)$.  Then the unique ball
$D\in T(R)$ with smallest radius $\rho_D\ge \max_{B\in R} \rho_{B}$
coincides with $\MBR(\emptyset,R)$.
\end{lemma}
%
\begin{proof}
Let $T'\subseteq T(R)$ be the set of all balls $D\in T(R)$ satisfying
$\rho_D\ge \max_{B\in R} \rho_{B}$.  Geometrically speaking, it should
be clear that a ball with center $c$ and radius $\rho$ is tangent to
the balls in~$R$ and encloses them all if and only if
\begin{equation}\label{prog_force}
\|c-c_B\| = \rho-\rho_B
\end{equation}
for all balls $B\in R$.  This, together with $\rho-\rho_B=\|c-c_B\|\ge
0$ and the assumption that the center of a ball in~$\MBR(\emptyset,R)$
lies in $\aff(C)$, implies $\MBR(\emptyset,R)\subseteq T'\subseteq
T(R)$.  Hence the radius $\rho$ and the center $c$ of a ball in
$\MBR(\emptyset,R)$ satisfy system~(\ref{b_lin}--\ref{b_quad}).  From
this and the existence of~$A_{m-1}^{-1}$ the uniqueness follows
already, because by~(\ref{b_lin}) two identical radii yield the same
$x$ and thus the same center $c= Q_{m-1}x+c_0$.  Moreover, a ball
$D\in T'$ satisfies $\|c_D-c_B\|^2=(\rho_D-\rho_B)^2$ for all $B\in R$
by definition of~$T(R)$, and consequently $\|c-c_B\|=|\rho_D-\rho_B|$,
where the absolute bars can be dropped because $\rho_D\ge \max_{B\in
R}\rho_B$.  This shows that any ball $D\in T'$ is tangent and
enclosing w.r.t.\ $R$, and since $\MBR(\emptyset,R)\subseteq T'$, the
claim follows.
\end{proof}
%
In our task of computing~$T(R)$ we thus need to solve the
system~(\ref{b_lin}) of~$m-1$ linear equations in the~$m$
unknowns~$x,\rho$.  In case the centers of~$R$ are affinely
independent, we face a regular coefficient matrix
(Lemma~\ref{lemma_Q}), which means that the solution space is a
one-dimensional line.  Taking into account the quadratic
polynomial~(\ref{b_quad}), we see that the solutions to~$T(R)$ lie
somewhere on this line, and there are at most two solutions if the
polynomial is non-zero, and infinitely many otherwise.\par\medskip
%
At this point we could implement the primitive as follows: We
compute~$T(R)$ using Lemma~\ref{lemma_TR} and select from it the
smallest ball with radius $\rho\ge \max \rho_i$; by
Lemma~\ref{lemma_constr}, this ball coincides with
$\MBR(\emptyset,R)$.  Then we check whether its center is a convex
combination of the centers of~$R$ and if so, return the ball, or
signal ``no'' otherwise.
%
\subsubsection{An incremental formula for the primitive}
%
Solving system~(\ref{b_lin}--\ref{b_quad}) by means of the
inverse~$A_{m-1}^{-1}$ has one major drawback: numerical
instability.\footnote{Another important advantage of an incremental
formula is that it provides a cheap way to compute the primitve's
output on~$R\cup\{B_m\}$ once we know its output on~$R$.}  Therefore
it makes sense to abandon the inverse and use another device.  The
following way of solving system~(\ref{b_lin}--\ref{b_quad}) is a
generalization of G\"artner's method~\cite{g-frseb-99} for enclosed
points.\par\medskip
%
So assume we are given~$2\le n\le d+1$ balls $\{B_0,\ldots,B_{n-1}\}$
and that we have already solved system~(\ref{b_lin}) for $m<n$ balls.
What is the solution of the corresponding system when we add the next
ball~$B_m$?
%
Setting $t = 2 A_{m-1}^{-1} Q_{m-1}^T C_m$ and $\alpha_m$ as on
page~\pageref{defs}, we have
\[
A_m = \left[
\begin{array}{cc}
A_{m-1} & 2Q_{m-1}^T C_m \\
%\hline
2 C_m^T Q_{m-1} & 2 C_m^T C_m
\end{array}
\right]
\quad\mbox{and}\quad
A_m^{-1} = \left[
\begin{array}{cc}
A_{m-1}^{-1} + \frac{tt^T}{\alpha_m} & -\frac{t}{\alpha_m} \\
%\hline
-\frac{t^T}{\alpha_m} & \frac{1}{\alpha_m}
\end{array}
\right]
\]
% A_m^{-1} = \left[
% \begin{array}{cc}
% A_{m-1}^{-1} + dd^T/{\alpha_m} & -d/{\alpha_m} \\
% %\hline
% -d^T/{\alpha_m} & 1/{\alpha_m}
% \end{array}
% \right]
% \]
% \[
% A_m = \left[
% \begin{array}{c|c}
% A_{m-1} &
% \begin{array}{c}2 C_1^T C_m \\ \vdots \\ 2 C_{m-1}^T C_m \end{array} \\
% \hline
% \begin{array}{ccc} 2C_1^T C_m & \cdots & 2C_{m-1}^T C_m \end{array} &
% 2 C_m^T C_m
% \end{array}
% \right]
% \]
which you can easily verify by multiplying out~$A_m A_m^{-1}$.  As is
mentioned in~\cite{g-frseb-99}, $A_m^{-1}$ may become ill-conditioned
(and consequently its entries very large and unreliable),
if~$\alpha_m$ evaluates to a very small number.  However, the
following lemma states a geometric interpretation of~$\alpha_m$ which
tells us that this only happens when the new point~$c_m$ is very close
to the affine hull of the previous ones.  Even better, the lemma
suggests that we use~$M_m$ as our device to solve
system~(\ref{b_lin}), because according to property~(iv) its entries
stay bounded.  (This of course doesn't imply that everything behaves
well in finite arithmetic\ldots)
%
\begin{lemma}\label{lemma_props}
Let~$R=\{B_0,\ldots,B_m\}$ be a set of at least three balls with
affinely independent centers and set $t=2A_{m-1}^{-1} Q_{m-1}^T C_m$
as above.  Then:
\begin{itemize}
\item[(i)] $Q_{m-1} t = \q{C}_m$, where $\q{C}_m$ is the projection of
the point~$C_m$ onto the subspace spanned by~$C_1,\ldots,C_{m-1}$.
%
\item[(ii)] $M_{m-1} C_m = \q{C}_m$ and $M_{m} C_{m} = C_{m}$.
%
\item[(iii)] $\alpha_m = 2\,(C_m-\q{C}_m)^T (C_m-\q{C}_m)$, i.e.,
$\alpha_m$ is twice the squared distance from the point~$C_m$ to its
projection.
%
\item[(iv)] $M_m$ is updated according to
\[ M_m = M_{m-1} + \frac{2}{\alpha_m}\,(C_m-\q{C}_m)\,(C_m-\q{C}_m)^T.
\]
%
\item[(v)]%
%The center~$Z_m$ and radius~$\delta_m$
%of~$\MBR(\emptyset,\{c_0,\ldots,c_m\})$ satisfy
The vectors $d_m$, $e_m$ and~$f_m$ are updated as
\begin{eqnarray*}
d_m &=& d_{m-1} + \frac{\delta_m}{\alpha_m}\,(C_m-\q{C}_m) \\
e_m &=& e_{m-1} + \frac{\epsilon_m}{\alpha_m}\,(C_m-\q{C}_m) \\
f_m &=& f_{m-1} + \frac{\phi_m}{\alpha_m}\,(C_m-\q{C}_m)
\end{eqnarray*}
%
\item[(vi)] The corresponding quadratic~(\ref{b_quad}) for~$m+1$ balls
is given by
% \begin{equation}\label{b_quad_plus}
% \begin{array}{c@@{\;\;}c@@{\;\;}c@@{\;}l}
% 0 &=& \rho^2 & (f_m^Tf_m-1) \\
%   &+& 2\rho  & (f_m^T\,(d_m+e_m)+\rho_0) \\
%   &+&        & (d_m+e_m)^T(d_m+e_m)-\rho_0^2
% \end{array}
% \end{equation}
\begin{eqnarray}
0 &=& \rho^2\,(f_m^Tf_m-1) \nonumber \\
  &+& 2\rho\,\left(f_m^T\,(d_m+e_m)+\rho_0\right) \label{b_quad_plus} \\
  &+& (d_m+e_m)^T(d_m+e_m)-\rho_0^2 \nonumber
\end{eqnarray}
\end{itemize}
%Consequently, $T(R)$ consists of the balls~$D$ with (shifted) center
%$C_D = d_m + e_m + \rho_D f_m$ where the radius $\rho_D$
%satisfies~(\ref{b_lin_plus}).
\end{lemma}
%
The statement is a generalization of~\cite[Lemma~1]{g-frseb-99}, and
it is worthwhile noting that the point $d_m+c_0$ is the center and
$d_m^T d_m$ the squared radius of the smallest enclosing ball of the
points~$\{c_0,\ldots,c_m\}$.
%The proof of the lemma is quite
%cumbersome and not really interesting; it involves elemantary
%calculations only.
%
%The proof involves elementary calculations only and is omitted
%here.
\par\medskip
\begin{proof}
(i)~We show that~$Q_{m-1}t-C_m$ is orthogonal to~$C_k$ for every~$1\le
k<m$.
%\[ \angl{Q_{m-1}t-C_m,C_k} = 2 C_m^T Q_{m-1}
%A_{m-1}^{-1} Q_{m-1}^T C_k - C_m^T C_k = 0
%\]
\[ Q_{m-1}^T\,(Q_{m-1}t-C_m) = 1/2 A_{m-1} t-Q_{m-1}^T C_m = 0
\]
%This holds because $2Q_{m-1}^T C_k$ equals the $k$-th column of the
%matrix~$A_{m-1}$.\par\medskip
%
(ii)~We have~$M_{m-1} C_m = 2 Q_{m-1} A_{m-1}^{-1} Q_{m-1}^T C_m$
where we can plug in the equation for~$t$.  This gives $M_{m-1} C_m =
Q_{m-1} t = \q{C}_m$ by property~(i).  Futhermore, notice that $2Q_m^T
C_m$ equals the last column~$a_m$ of the matrix~$A_m$, and consequently $M_mC_m
= 2 Q_m A_m^{-1} Q_m^T C_m = C_m$.\par\medskip
%
(iii)~Expanding $2\,(C_m-\q{C}_m)^T (C_m-\q{C}_m)$ gives $2 C_m^T C_m
- 4 C_m^T \q{C}_m + 2 \q{C}_m^T \q{C}_m$ and we show that the sum of
the last two terms equals $-2C_m^T M_{m-1} C_m$ as needed.
%\begin{eqnarray*}
%2\,(C_m-\q{C}_m)^T (C_m-\q{C}_m) &=& 2\,(C_m-M_{m-1}C_m)^T (C_m-M_{m-1}C_m)\\
% &=& 2C_m^T C_m - 4 C_m^T M_{m-1} C_m + 2 C_m^T M_{m-1}^T M_{m-1} C_m \\
% &=& 2C_m^T C_m - 2 C_m^T \,(2I+ M_{m-1}^T)\,M_{m-1} C_m
%\end{eqnarray*}
\begin{eqnarray*}
- 4 C_m^T \q{C}_m + 2 \q{C}_m^T \q{C}_m &=&
- 4 C_m^T M_{m-1} C_m + 2 C_m^T M_{m-1}^T M_{m-1} C_m^T \\
&=& - 2 C_m^T M_{m-1} C_m
\end{eqnarray*}
Hereby we have used property~(ii) and the fact~$M_{m-1}^T
M_{m-1}=M_{m-1}$ which is easily verified by expanding the
expression.\par\medskip
%
For the proof of the next two properties we need the following little
calculation which follows from the previously developed representation
of~$A_m^{-1}$ in terms of~$A_{m-1}^{-1}$, from~$Q_m = [Q_{m-1},C_m]$
and from property~(i).
\begin{equation}\label{zwischen}
Q_m A_m^{-1} =
%\frac{1}{\alpha_m}\,
\left[
Q_{m-1} A_{m-1}^{-1} + (\q{C}_m - C_m)\,t^T/\alpha_m,
(C_m-\q{C}_m)\,/\alpha_m\right]
\end{equation}
(iv)~It suffices to plug the above formula into~$M_m = 2 Q_m A_m^{-1}
Q_m^T$.\par\medskip
%\[ M_m = M_{m-1}+ \frac{2}{\alpha_m}\,\left(\q{C}_m\q{C}_m^T
% -2C_m \q{C}_m^T +C_m C_m^T \right).
%\]
(v)~Notice $t^T v_{m-1}=2C_m^T d_{m-1}$, $t^T w_{m-1} =
% 2 C_m Q_{m-1} A_{m-1}^{-1}w_{m-1} =
2 C_m^T e_{m-1}$ and $t^T r_{m-1} = 2 C_m^T f_{m-1}$.
\[
\renewcommand{\arraystretch}{2.3}
\begin{array}{r@@{\;}c@@{\;}l}
d_m &=& Q_m A_m^{-1}
\left[
\renewcommand{\arraystretch}{1}
\begin{array}{c}
v_{m-1} \\
C_m^T C_m
\end{array}
\renewcommand{\arraystretch}{2.3}
\right] =
d_{m-1}+\frac{C_m^T C_m-2C_m^T d_{m-1} }{\alpha_m}\,(C_m-\q{C}_m) \\
e_m &=& Q_m A_m^{-1}
\left[
\renewcommand{\arraystretch}{1}
\begin{array}{c}
w_{m-1} \\
\rho_0^2 - \rho_m^2
\end{array}
\renewcommand{\arraystretch}{2.3}
\right] =
e_{m-1}+\frac{\rho_0^2-\rho_m^2-2C_m^T e_{m-1}}{\alpha_m}\,(C_m-\q{C}_m) \\
f_m &=& Q_m A_m^{-1}
\left[
\renewcommand{\arraystretch}{1}
\begin{array}{c}
r_{m-1} \\
2\rho_m - 2\rho_0
\end{array}
\renewcommand{\arraystretch}{2.3}
\right] =
f_{m-1}+2\,\frac{\rho_m-\rho_0-C_m^T f_{m-1}}{\alpha_m}\,(C_m-\q{C}_m)
\end{array}
\renewcommand{\arraystretch}{1}
\]
To show~(vi), we plug $Q_m x = d_m+e_m+\rho f_m$ into the
corresponding system~(\ref{b_lin}) for~$m+1$ balls.  This gives the
following chain of equations.
\begin{eqnarray*}
 (\rho-\rho_0)^2 &=&  1/2\,x^T A_m x \\
&=& (Q_m x)^T Q_m x \\
&=&  (d_m+e_m)^T (d_m+e_m) + 2\rho f_m^T\,(d_m + e_m) + \rho^2 f_m^T f_m
\end{eqnarray*}
Rearranging terms produces~(\ref{b_quad_plus}).
\end{proof}
%
Combining the above update formulas with Lemma~\ref{lemma_TR}, we
see that $D\in T(R)$ if and only if $C_D = Q_m x = d_m + e_m + \rho_D
f_m$ where the radius~$\rho_D$ of~$D$ satisfies~(\ref{b_quad_plus}).
So an update step looks as follows: We compute $\q{C}_m$ using
propery~(ii), then evaluate~$\alpha_m$ according to~(iii),
update~$\delta_m$, the other scalars, $d_m$, $e_m$, $f_m$ and~$M_m$
itself.  Finally, we solve the quadratic~(\ref{b_quad_plus}) and
substitute the obtained radii~$\rho_D$ into $C_D=d_m+e_m+\rho_D f_m$.
%
\subsubsection{Implicitly representing the device~$M_m$}\label{sect_implicit}
%
Although the incremental formulas from the previous section provide
simple means to compute~$T(R)$, it is not clear anymore how to use
them in implementing the primitive.  There we need to check whether a
ball in~$T(R)$ coincides with~$\MB(R)$, and this we do using the
coefficients~$x$ in the representation~(\ref{affine_comb}) of the
ball's center as an affine combination of the centers of~$R$: If
$x_i\ge 0$ for all~$i$, then (and only then) the ball coincides
with~$\MB(R)$.  Unfortunately, we do not have immediate access to the
$x_i$'s anymore when working with the improved device~$M_m$!  The
following remedy (based on~\cite{g-frseb-99} again) allows us to
maintain $M_m$ in such a way that the coefficients are at hand again.
%
\begin{lemma}\label{lemma_sum}
Let $R=\{B_0,\ldots,B_{m-1}\}$ be a set of at least two balls with
affinely independent centers and denote by~$C=C(\rho)$ a solution of
system~(\ref{b_lin}--\ref{b_quad}). Set
\[ \alpha_1:= 2 C_1^T C_1 \qquad \mbox{and}\qquad  d_0 := e_0:= f_0:= 0
\]
such that the values $\alpha_k$, $\delta_k$, $\epsilon_k$ and
$\phi_k$ are also defined for $k=1$.  Then
% By setting $d_0$, $e_0$ and $f_0$ to the zero
% vector and $\alpha_1:= 2 C_1^T C_1$, the values $\alpha_k$,
% $\delta_k$, $\epsilon_k$ and $\phi_k$ are also defined for $k=1$.
% This gives
\begin{eqnarray}
M_{m-1} &=&
\sum_{i=1}^{m-1}\,\frac{2}{\alpha_i}\,(C_i-\q{C}_i)\,(C_i-\q{C}_i)^T
\label{M_as_sum}, \\
C &=& \sum_{i=1}^{m-1}\,\frac{\delta_i+\epsilon_i+\rho\phi_i}{\alpha_i}\,
(C_i-\q{C}_i).
\label{C_as_sum}
\end{eqnarray}
\end{lemma}
%
Notice that the projection~$\q{C}_1$ of~$C_1$ to the linear span of
the empty set is the zero vector.  So the formula $\alpha_k =
2\,(C_k-\q{C}_k)^T(C_k-\q{C}_k)$ holds for all~$k\ge 1$.\par\medskip
%
\begin{proof}
Using the definitions from page~\pageref{defs}, we immediately get
$Q_1=C_1$ and~$A_1 = 2C_1^TC_1\in\R$.  Consequently, we have
\[ M_1 = 2 Q_1 A_1^{-1} Q_1^T = \frac{2}{\alpha_1}\,C_1 C_1^T =
\frac{2}{\alpha_1}\,(C_1-\q{C}_1)\,(C_1-\q{C}_1)^T.
\]
Formula~(\ref{M_as_sum}) now follows from Lemma~\ref{lemma_props}.
Along the same lines we get
\begin{eqnarray*}
d_1 &=& Q_1 A_1^{-1} v_1 = \frac{C_1^T C_1}{\alpha_1}\,C_1 = \frac{\delta_1}{\alpha_1}\,(C_1-\q{C}_1), \\
e_1 &=& Q_1 A_1^{-1} w_1 = \frac{\rho_0^2-\rho_1^2}{\alpha_1}\,C_1 = \frac{\epsilon_1}{\alpha_1}\,(C_1-\q{C}_1), \\
f_1 &=& Q_1 A_1^{-1} r_1 = \frac{2\rho_1-2\rho_0}{\alpha_1}\,C_1 = \frac{\phi_1}{\alpha_1}\,(C_1-\q{C}_1).
\end{eqnarray*}
Formula~(\ref{C_as_sum}) now follows from $C(\rho)=Q_m x = d_m+e_m+\rho
f_m$ and Lemma~\ref{lemma_props}.
\end{proof}
%
So our update formulas yield a representation of~$C(\rho)$ as
\begin{equation}\label{def_beta}
C = \sum_{i=1}^{m-1} \beta_i\,(C_i-\q{C}_i), \qquad\mbox{where} \qquad
\beta_i:= \frac{\rho_i+\epsilon_i+\rho\phi_i}{\alpha_i}.
\end{equation}
But what we actually need is a representation of the form
$C=\sum_{i=1}^{m-1} \gamma_i C_i$, so that we can easily check whether
$c$ is a convex combination of the~$c_i$'s: Writing
\begin{eqnarray*}
c &=& C+c_0 \\
  &=& \sum_{i=1}^{m-1} \gamma_i C_i + c_0 \\
  &=& \sum_{i=1}^{m-1} \gamma_i\,(c_i-c_0) + c_0 \\
  &=& \sum_{i=1}^{m-1} \gamma_i c_i + (1-\sum_{i=1}^{m-1} \gamma_i)\,c_0,
\end{eqnarray*}
% \[ c = C+c_0 = \sum_{i=1}^m \gamma_i C_i + c_0 =
% \sum_{i=1}^m \gamma_i\,(c_i-c_0) + c_0 =
% \sum_{i=1}^m \gamma_i c_i + (1-\sum_{i=1}^m \gamma_i)\,c_0,
% \]
we see that $c$ is a convex combination of the~$c_i$'s if and only if
all coefficients~$\gamma_i$ in $C=\sum_{i=1}^{m-1} \gamma_i C_i$ are
greater or equal to zero and $\sum_{i=1}^{m-1} \gamma_i \le
1$.\par\medskip
%
In order to convert representation~(\ref{C_as_sum}) to the
form $C=\sum \gamma_i C_i$ we need to know the
coefficients~$\tau_{ji}$ of~$C_j-\q{C}_j$ in the representation
$C_i = \sum_{j=1}^{m-1} \tau_{ji}\,(C_j-\q{C}_j)$.
So substitute~(\ref{M_as_sum}) into~$M_iC_i=C_i$
(Lemma~\ref{lemma_props}.ii).  Comparing coefficients yields
\begin{equation}\label{eq_tau}
\tau_{ji} = \left\{
\begin{array}{cl}
0 & \mbox{(if $j > i$)} \\
\frac{2}{\alpha_j}\,(C_j-\q{C}_j)^TC_i &  \mbox{(if $j\le i$)}
\end{array}
\right..
\end{equation}
In particular, we have $\tau_{ii} = 1$.  Going from $C = \sum\gamma_i C_i$
to $C=\sum \beta_i\,(C_i-\q{C}_i)$ amounts thus to solving the following
linear system:
\[
\left[\begin{array}{c}
\beta_1 \\
\vdots \\
\beta_{m-1}
\end{array}\right]
=
\left[\begin{array}{cccc}
 \tau_{11} & \tau_{12} & \cdots & \tau_{1,m-1} \\
           & \tau_{22} & \cdots & \tau_{2,m-1} \\
           &           & \ddots & \vdots    \\
           &           &        & \tau_{m-1,m-1}
% \tau_{11} & \cdots & \tau_{1m} \\
% \vdots    &        & \vdots    \\
% \tau_{m1} & \cdots & \tau_{mm}
\end{array}\right]
\left[\begin{array}{c}
\gamma_1 \\
\vdots \\
\gamma_{m-1}
\end{array}\right]
\]
Since the system is triangular (with ones in the diagonal), we can use
back substitution to get the desired coefficients $\gamma_i$ as
\begin{equation}\label{coeffsgamma}
\gamma_i = \beta_i - \sum_{j=i+1}^{m-1} \gamma_j \tau_{ij} \qquad
(i=m-1,\ldots,1).
\end{equation}
%
Before we glue these ingredients together, let me mention a little
remark on how to solve the quadratic~(\ref{b_quad_plus}).  (Since we
won't stop before having used all Greek letters, we use this occasion
to define some more.)
%
\begin{lemma}\label{lemma_cpo}
In the setup of Lemma~\ref{lemma_props}, consider the
quadratic~(\ref{b_quad_plus}), mulitplied by the factor~2.  Its coefficents,
that is the numbers
\[ \chi_k:=2\left(f_k^T f_k - 1\right), \quad
 \psi_k:= 4\left(f_k^T(d_k+e_k)+\rho_0\right), \quad
\omega_k:= 2\,(d_k+e_k)^T (d_k+e_k)-2\rho_0^2
\]
are updated acoording to the following formulas
\[
\chi_{m} = \chi_{m-1} + \frac{\phi_m^2}{\alpha_m}, \quad
\psi_{m} = \psi_{m-1} + \frac{2\phi_m\,(\delta_m+\epsilon_m)}{\alpha_m}, \quad
\omega_{m} = \omega_{m-1} + \frac{(\delta_m+\epsilon_m)^2}{\alpha_m}.
\]
\end{lemma}
%
\begin{proof}
Observe that $Q_{m-1}^T\,(C_m-\q{C}_m)=0$ by property~(i) of
Lemma~\ref{lemma_props}.  Hence
\begin{equation}\label{dd}
d_m^T d_m = d_{m-1}^T d_{m-1} +
\frac{\delta_m^2}{\alpha_m^2}\,(C_m-\q{C}_m)^T(C_m-\q{C}_m)
= d_{m-1}^T d_{m-1} +
\frac{\delta_m^2}{2\alpha_m}.
\end{equation}
In a similar way we can expand $f_m^T f_m$, $f^T(d_m+e_m)$ and
$(d_k+e_k)^T(d_k+e_k)$, from which the claim follows.
\end{proof}
%
\subsubsection{The skeleton of routine \code{push()}}
%
We are now ready to fully implement the class \code{Support\_set}.
First of all, an instance stores the number $\code{m}=|R|$ of balls
which have been pushed so far and keeps for every $0\le i<m$ a pointer
\code{b[$i$]} to the $(i+1)$-th pushed ball.  In addition we maintain
the variables defined below with the invariants that:\par\medskip
%
\begin{itemize}
\item For every $1\le i<\code{m}$, the vector \code{u[i]} is equal to
$C_i-\q{C}_i$.
\item For every $0\le i<\code{m}$ and $z\in\{d,e,f\}$, the variable
\code{z[i]} is equal to~$z_i$.
\item For every $1\le i<\code{m}$ and
$z\in\{\alpha,\delta,\epsilon,\phi\}$, the variable \code{z[i]} is
equal to~$z_i$.
\item For every $0\le i<\code{m}$, the variable \code{sigma[i]} is equal
to~$d_i^T d_i$.
\item For every $0\le i<\code{m}$ and
$z\in\{\chi,\psi,\omega\}$, the variable \code{z[i]} is equal
to~$z_i$.
\item For all $1\le i<j<\code{m}$, the variable \code{tau[i][j]} contains the
value of~$\tau_{ij}$.
\item For all $1\le i\le\code{m}$, the variable \code{sol[i]} contains
the radius of $\MBR(\emptyset,\{B_0,\ldots,B_{i-1}\})$, where
$R=\{B_0,\ldots,B_{m-1}\}$ is the set of pushed balls (in this order).
%
Since under exact computation this radius is a pair, we also
store the discriminant in \code{discrim[i]} for every $1\le i
\le\code{m}$.
%
\item For all $0\le i<m$, the variable \code{maxradius[i]} contains
$\max_{0\le j \le i} \rho_j$.
\end{itemize}\par\medskip
%
Let us consider the case when $R$ constitutes a basis of $R$, which in
particular means $\MB(R)=\MBR(\emptyset,R)$.  Here, Corollary~3
from~\cite{fg-sebbcsa-03} (together with the fact that the optimal
value of the mathematical program $P_{\mathbf{0}}(U,V)$ appearing in
the lemma cannot increase if we drop constraints) implies that
$\MBR(\emptyset,R')$ exists for every subset $R'\subseteq R$, and that
its center lies in the affine hull of the centers of~$R'$.  Thus, in
the case when our primitive must compute $\MB(R)=\MBR(\emptyset,R)$,
the ball $\MBR(\emptyset,R')$ exists for all ``stacks'' $R'$ occurring
during the construction of~$R$.  Consequently, the second-to-last
invariant can indeed be satisfied and the quadratic
equation~(\ref{b_quad_plus}) will have at least one real solution
$\code{sol[i]}\ge\max_{0\le j<i}\rho_j$ for every $1\le i\le
m$.\par\medskip
%
In the following, I call the set of variables involved in these
invariants the \e{device}.\par\medskip
%
@$@<member fields of class Support_set@>==@{@-
int m;                    // number of pushed balls
const Sphere *b[D+1];     // pointers to pushed balls
Result center[D+1];       // contains, when is_spanning() returns true,
                          // the center of the miniball

// variables of the device:
FT u[D+1][D];
FT d[D+1][D];
FT e[D+1][D];
FT f[D+1][D];
FT alpha[D+1];
FT delta[D+1];
FT eps[D+1];
FT phi[D+1];
FT sigma[D+1];
FT chi[D+1];
FT psi[D+1];
FT omega[D+1];
FT tau[D][D+1];
Result sol[D+2];
FT discrim[D+2];
FT maxradius[D+1];@-
@}\par\medskip%
%
%
In the routine \code{push($B$)} we first store a pointer to~$B$ in
\code{b[m]} and then compute the values of the variables \code{v[m]}
for all~\code{v} in the device.  Having done this, we can safely
increase~\code{m} by one without violating the above invariants.
However, we will refrain from incrementing~\code{m} in case we realize
that \code{alpha[m]} drops to zero.  In such a situtation,
Lemma~\ref{lemma_props} toghether with the fact that a basis has
affinely independent centers tells us that the balls~$R\cup\{B\}$
cannot be part of any basis, allowing us to return \code{false}
here.\par\medskip
%
@$@<routine push()@>==@{@-
template<class Traits>
bool Support_set<Traits>::push(const Sphere& ball) {
  CGAL_MINIBALL_DO_DEBUG(is_spanning_was_called = false);

  if (m > D)
    return false;

  b[m] = &ball;

  if (m == 0) {
    @<base case in push()@>
  } else {
    @<update case in push()@>
  }

  ++m;
  return true;
}
@}\par\medskip%
%
When no ball has been pushed so far, we simply set the values of all
those variables of the device which are defined for index
zero:%
%
\par\medskip
%
@$@<base case in push()@>+=@{@-
for (int j=0; j<D; ++j)
  d[0][j] = e[0][j] = f[0][j] = 0;
sigma[0]     = 0;
chi[0]       = -2;
psi[0]       = FT(+4) * t.radius(ball);
omega[0]     = FT(-2) * sqr(t.radius(ball));
sol[1]       = t.radius(ball);
discrim[1]   = 0;
maxradius[0] = t.radius(ball);
@}\par\medskip%
%
If $B$ is not the first ball to push, we have more work to do in order
to maintain the invariants.  To find the value of \code{u[m]} we need
the vector~$\q{C}_m$, which according to Lemma~\ref{lemma_props} can
be computed as $\q{C}_m = M_{m-1}C_m$.  But since
\[
\q{C}_m = M_{m-1} C_m =
\sum_{i=1}^{m-1}\,\frac{2}{\alpha_i}\,(C_i-\q{C}_i)\,(C_i-\q{C}_i)^T
C_m = \sum_{i=1}^{m-1} \tau_{im}\,(C_i-\q{C}_i),
\]
it suffices to compute the values $\tau_{im}$ for $1\le i<m$ according
to equation~(\ref{eq_tau}) and calculate the sum on the right-hand
side.  This shows how to find \code{u[m]}.  The vectors \code{d[m]},
\code{e[m]}, \code{f[m]} and the number \code{alpha[m]} can be
computed according to Lemma~\ref{lemma_props}, the numbers
\code{delta[m]}, \code{eps[m]}, \code{phi[m]} according to their
definition, \code{sigma[m]} according to equation~(\ref{dd}) and the
remaining variables according to Lemma~\ref{lemma_cpo}.  (The
%
variables
\code{sol[$m+1$]}
 and \code{discrim[$m+1$]} are
%
computed in routine \code{find\_radius()}.)\par\medskip
%
@$@<update case in push()@>==@{@-
// calculate $C_m$, storing it (temporarily) in u[m]:
CIt c   = t.center_cartesian_begin(*b[m]),
    c_0 = t.center_cartesian_begin(*b[0]);
for (int j=0; j<D; ++j) {
  u[m][j] = *c - *c_0;
  ++c; ++c_0;
}

// compute $\tau_{im}$ for $1<=i<m$:
for (int i=1; i<m; ++i) {
  tau[i][m] = 0;
  for (int j=0; j<D; ++j)
    tau[i][m] += u[i][j]*u[m][j];
  tau[i][m] *= FT(2);
  tau[i][m] /= alpha[i];
}

// compute maxradius[m]:
maxradius[m] = std::max(maxradius[m-1],t.radius(*b[m]));

// calculate delta[m], eps[m] and phi[m] (by definition):
const FT t1 = t.radius(*b[0]) - t.radius(*b[m]),
             t2 = t.radius(*b[0]) + t.radius(*b[m]);
phi[m]   = eps[m] = 0;
delta[m] = -sigma[m-1];
for (int j=0; j<D; ++j) {
  eps[m]   -= u[m][j]*e[m-1][j];
  phi[m]   -= u[m][j]*f[m-1][j];
  delta[m] += sqr(u[m][j]-d[m-1][j]);
}
phi[m] = FT(2)*(phi[m] - t1);
eps[m] = t1*t2+FT(2)*eps[m];

// fix u[m] to be $C_m-\q{C}_m$:
// (This is only necessary for m>1 because $\q{C}_1=0$.)
for (int i=1; i<m; ++i)
  for (int j=0; j<D; ++j)
    u[m][j] -= tau[i][m]*u[i][j];

// calculate alpha[m]:
alpha[m] = 0;
for (int j=0; j<D; ++j)
  alpha[m] += sqr(u[m][j]);
alpha[m] *= FT(2);

// reject push if alpha[m] is to small:
@<reject push if necessary@>@-

// calculate d[m], e[m] and f[m]:
const FT da = delta[m]/alpha[m],
             ea = eps[m]/alpha[m],
             fa = phi[m]/alpha[m];
for (int j=0; j<D; ++j) {
  d[m][j] = d[m-1][j] + da*u[m][j];
  e[m][j] = e[m-1][j] + ea*u[m][j];
  f[m][j] = f[m-1][j] + fa*u[m][j];
}

// compute sigma[m], chi[m], psi[m] and omega[m]:
const FT de = delta[m]+eps[m];
sigma[m] = sigma[m-1] + delta[m]*da/FT(2);
chi[m]   = chi[m-1]   + phi[m]*fa;
psi[m]   = psi[m-1]   + FT(2)*de*fa;
omega[m] = omega[m-1] + de*de/alpha[m];

// compute sol[m+1]:
if (find_radius(Is_exact()) == false)
  return false;
@}\par\medskip%
%
After having computed $\alpha_m$, we need to check that it is non-zero.
%
When we are dealing with floating-point numbers, we
%
need a more appropriate test than \code{alpha[m]!=0.0}.  The following
relative criterion seems to work well in practice (but a better one
would always be welcome): Recall that $\alpha/2$ is the squared
distance from the center of~$B$ to the affine hull of the already
pushed balls~$R$.  The idea is to reject the ball $B$ if and only if
the \e{relative} distance to the affine hull is small, that is when
\[
\frac{\alpha_m}{\rho_{\mathrm curr}^2} < \varepsilon
\]
for some constant $\varepsilon$, where $\rho_{\mathrm curr}$ is the
radius of $\MBR(\emptyset,R')$, i.e., $\rho_{\mathrm
curr}=\code{sol[m]}$.  Consequently, we have:\par\medskip
%
@$@<reject push if necessary@>==@{@-
if (reject(alpha[m],sol[m],Is_exact()))
  return false;@-
@}
\par\medskip
%
@$@<routine reject()@>==@{@-
template<typename FT>
inline bool reject(const FT& alpha,const FT& prev,
                   const Tag_false is_exact) {
  using namespace Min_sphere_of_spheres_d_impl;
  return alpha < SqrOfEps*sqr(prev);
}

template<typename FT,typename Pair>
inline bool reject(const FT& alpha,const Pair&,
                   const Tag_true is_exact) {
  return alpha == FT(0);
}

@}
%
%
\subsubsection{Computing the radius in \code{push()}}
%
We compute $\MBR(\emptyset,R)$, $R$ being the set of currently pushed
balls, using the device $M_m$ from section~\ref{sect_implicit}.
Recall that it suffices to do the computation when $R$ is a subset of
a basis, so we can assume the centers of~$R$ to be affinely
indepedent.  From Lemma~13(i) in~\cite{fg-sebbcsa-03} (and the fact that
the optimal value of program ${\cal P}_{\mathbf{0}}(U,V)$ appearing in
the lemma cannot increase if we drop constraints), it then follows
that $D:= \MBR(\emptyset,R)$ exists and is unique, and that its center
lies in the affine hull of the centers of~$R$.  Consequently, $D\in
T(R)$ and we can compute it by solving
system~(\ref{b_lin}--\ref{b_quad}).  So we first compute the
balls~$T(R)$ and select among them the smallest ball~$D$ (if any) with
$\rho_D\ge\max_{B\in R}\rho_B$.  If there is no such ball, then we
immediately abort \code{push()} by returning \code{false} (since $R$
cannot be part of any basis in this case).  On the other hand, if
there exists such a ball~$D$, then we save its center and radius and
return \code{true} to the caller of \code{push()}.\par\medskip
%
Finding the solutions of the quadratic is done using a ``numerically
stable'' formula from~\cite{g-wecsskafpa-91}.  Since we are allowed to
signal ``no'' in case the pushed balls do not form a basis, we can
abort immediately, if all solutions are negative or complex.
%
Notice however, that it is possible for $\chi_{m}$ to become zero in
which case $T(R)$ consists of one ball only.  Also, it need not always
be the case that $\code{sols[0]}\ge\code{sols[1]}$ at line~({\tt *}):
If $\chi_{m}$ gets negative\footnote{Take all radii to be zero, for
instance.}, it is necessary to swap these variables.  In any case, the
routine \code{find\_radius()} returns true if and only if a
radius~$\rho$ satisfying $\rho\ge \max_{B\in R}\rho_B$ has been found,
in which case $\rho$ is, by Lemma~\ref{lemma_constr} the radius of
$\MBR(\emptyset,R)$.\par\medskip
%
@$@<routine find_radius()@>==@{@-
template<class Traits>
bool Support_set<Traits>::find_radius(const Tag_false is_exact) {
  using namespace Min_sphere_of_spheres_d_impl;

  // find discriminant:
  discrim[m+1] = sqr(psi[m]) - 4*chi[m]*omega[m];
  if (discrim[m+1] < Min_float)
    return false;

  // handle degenerate quadratic:
  if (std::abs(chi[m]) < Min_float) {
    if (std::abs(psi[m]) < Min_float)
      return false;
    sol[m+1] = -omega[m]/psi[m];
    return sol[m+1]*Tol >= maxradius[m];
  }

  // calculate the two solutions:
  FT sd = std::sqrt(discrim[m+1]);
  if (psi[m] > 0)
    sd = -sd;
  Result sols[2] = { (sd-psi[m])     / (FT(2)*chi[m]),
                      FT(2)*omega[m] / (sd-psi[m]) };

  // order the solutions (*):
  if (sols[1] < sols[0])
    std::swap(sols[0],sols[1]);

  // eliminate negative solutions:
  if (sols[0]*Tol >= maxradius[m]) {
    sol[m+1] = sols[0];
    return true;
  }
  sol[m+1] = sols[1];
  return sol[m+1]*Tol >= maxradius[m];
}

template<class Traits>
bool Support_set<Traits>::find_radius(const Tag_true is_exact) {
  // find discriminant:
  discrim[m+1] = sqr(psi[m]) - FT(4)*chi[m]*omega[m];
  if (discrim[m+1] < FT(0))
    return false;

  // handle degenerate quadratic:
  if (chi[m] == FT(0)) {
    if (psi[m] == FT(0))
      return false;
    sol[m+1] = Pair<FT>(-omega[m]/psi[m],FT(0));
    return sol[m+1].first >= maxradius[m];
  }

  // calculate the two solutions:
  const FT tmp = FT(-1)/(FT(2)*chi[m]);
  Result sols[2] = {
    Pair<FT>(psi[m]*tmp, tmp),
    Pair<FT>(psi[m]*tmp,-tmp)
  };

  // order the solutions (*):
  if (chi[m] < FT(0))
    std::swap(sols[0],sols[1]);
  CGAL_MINIBALL_ASSERT(is_neg_or_zero(sols[0]-sols[1],discrim[m+1]));

  // eliminate negative solutions:
  if (!is_neg(sols[0]-maxradius[m],discrim[m+1])) {
    sol[m+1] = sols[0];
    return true;
  }
  sol[m+1] = sols[1];
  return !is_neg(sols[1]-maxradius[m],discrim[m+1]);
}
@}\par\medskip%
%
%
%
\subsubsection{The routine \code{pop()}}
%
The routine \code{pop()} is simple, since we do not violate any
invariants by decrementing~\code{m}:\par\medskip
%
@$@<routine pop()@>==@{@-
template<class Traits>
void Support_set<Traits>::pop() {
  CGAL_MINIBALL_ASSERT(m>0);
  CGAL_MINIBALL_DO_DEBUG(is_spanning_was_called = false);
  --m;
}@+@}
%
\subsubsection{The routine \code{is\_spanning()}}
%
When \code{is\_spanning()} gets called, the radius of the smallest
enclosing ball in~$T(R)$ has already been computed in~\code{sol[$m$]}.
So we can compute its center~$c = C+c_0$ according to
equation~(\ref{def_beta}), where we store the number $\beta_i$ (for
$i=1,\ldots,m-1$) in the variable \code{beta[$i$]}.  (Variable
\code{beta[0]} is not used to make things more readable.)\par\medskip
%
@$@<routine is_spanning()@>==@{@-
template<class Traits>
bool Support_set<Traits>::is_spanning() {
  CGAL_MINIBALL_DO_DEBUG(is_spanning_was_called = true);
  Result beta[D+1];

  // make sure at least one ball got pushed:
  CGAL_MINIBALL_ASSERT(m > 0);

  copy_n<D>(t.center_cartesian_begin(*b[0]),center);

  if (m > 1) {
    // compute the coeffients beta[i] and the center:
    for(int i=1; i<m; ++i) {
      beta[i] = (delta[i]+eps[i]+sol[m]*phi[i])/alpha[i];
      for (int j=0; j<D; ++j)
        center[j] += beta[i]*u[i][j];
    }

    // check whether the ball with center center and
    // radius sol[m] coincides with the miniball of the
    // pushed balls:
    @<check whether the center lies in the convex hull@>
  }

  return true;
}@}\par\medskip%
%
After having computed the center of $D:=\MBR(\emptyset,R)$, we check
whether $D$ coincides with $\MB(R)$.  By Lemma~\ref{lemma_seidel},
this is equivalent to the center~$c$ of~$D$ lying in the convex hull
of the centers of~$R$.  Thus, we compute the representation
$c=\sum_{i=1}^{m-1}\gamma_i c_i + (1-\sum_{i=1}^{m-1}\gamma_i)\,c_0$
as discussed earlier (were the coefficients $\gamma_i$ are computed by
equation~(\ref{coeffsgamma}) from the $\beta_i$'s and $\tau_{ij}$'s)
and check wether all $\gamma_i\ge 0$.\par\medskip
%
@$@<check whether the center lies in the convex hull@>==@{@-
Result gamma[D+1];
Result mingamma(0);
Result gamma0(1);

for (int i=m-1; i>0; --i) {
  gamma[i] = beta[i];
  for (int j=i+1; j<m; ++j)
    gamma[i] -= gamma[j]*tau[i][j];
  gamma0 -= gamma[i];
  if (is_neg(gamma[i]-mingamma,discrim[m]))
    mingamma = gamma[i];
}
if (is_neg(gamma0-mingamma,discrim[m]))
  mingamma = gamma0;

return !is_neg(mingamma,discrim[m]);@-
@}
%
This completes the implementation of class \code{Support\_set}.
%
\subsection{The basis computation \code{pivot()}}
\label{sec:pivot}
%
We solve the basis computation by brute force in this implementation.
We hope to provide a better method some day, because this is by far
the weakest part of the package.  Nonetheless, here's how it
works.\par\medskip
%
When \code{pivot()} is called, we are given a basis~$C$ and a ball~$d$
not contained in~$\MB(C)$, and we are to produce a basis~$C'$ of
$C\cup\{d\}$.  In the setup of \code{pivot()} the basis~$C$ as well as
the ball~$d$ are given implicitly.  (We will come to that later during
the discussion of the LP-algorithm and the heuristic.)  There is a
vector \code{l} of balls and an integer $0\le e\le d+1$
such that the balls \code{l[$0$..$(e-1)$]} constitute the basis~$C$.
The ball $d$ is given implictly as \code{l[d]}.  When \code{pivot()}
returns, the variable $e$ will be adjusted and the elements in the
vector~\code{l} rearranged in such a way that balls
\code{l[$0$..$(e-1)$]} consistute~$C'$.\par\medskip
%
Normally, \code{pivot()} returns true, signalling that the new
basis~$C'$ was found.  But as we will see, \code{pivot()} may fail
under certain circumstances and may be unable to compute~$C'$ (due to
numerical problems---in theory, $C'$ always exists).  In such a
situation \code{pivot()} returns \code{false}, leaving $e$ and~\code{l}
unchanged.\par\medskip
%
\begin{figure}[tbhp]
\begin{center}
\psfrag{$C_1$}{$C_0$}
\psfrag{$C_2$}{$C_1$}
\psfrag{$C_3$}{$C_2$}
\psfrag{$D$}{$d$}
\includegraphics{figs/pivot/cex.xfig.eps}
\caption{\label{fig_pivot}The basis computation \code{pivot($C$,$d$)}.}
\end{center}
\end{figure}
%
Since we know that $d$ must be contained in the new basis~$C'$, we can
compute~$C'$ by inspecting all subsets~$T\subseteq C$: For (at least)
one such~$T$ the set $T\cup\{d\}$ will be a basis of $C\cup\{d\}$.
Since we will iterate over the subsets~$T$ in such a way that we see
all proper subsets of~$T$ before encountering~$T$ itself, we can
conclude that the first set~$T$ with the property that $T\cup\{d\}$
forms a support set of itself must form a basis
of~$C\cup\{d\}$.\par\medskip
%
We denote subsets of~$C=\{C_0,\ldots,C_{e-1}\}$ by bit-strings of
width~$e$.  So $01010\cdots0$ represents the set~$\{C_1,C_3\}$, for
instance.  Then one way of iterating over the subsets~$T$ in such a
way that we see the proper subsets first is achieved by a call
\code{gen($0$)} to the following recursive procedure (in pseudo-code),
where $T$ is a bit-string of width~$e$:\par\medskip
%
@$@<generating the subsets@>@Z==@{@-
void gen(pos) {
  if (pos == e)
     output(T);
  else {
     clear bit pos of T;
     gen(pos+1);
     set bit pos of T;  // (*)
     gen(pos+1);
  }
}@}\par\medskip
%
Figure~\ref{fig_pivot} illustrates this method.  We are given a
basis~$C$ consisting of two points and ball, together with another
point~$d$ not contained in~$\MB(C)$.  The sets produced by
\code{gen($0$)} are listed in figure~\ref{fig_pivot_tab}.  For every
set~$T$ we check, using an instance \code{ss} of class
\code{Support\_set}, whether $T\cup\{d\}$ constitutes a support set of
itself (e.g., whether \code{is\_spanning()} returns true after having pushed
the members of the set onto~\code{ss}).  If this is the case, we check
whether the ball $\MB(T\cup\{d\})$ (which we obtain by
querying~\code{ss}) encloses all other balls in~$C\cup\{d\}$.  If so,
we have found a support set of~$C\cup\{d\}$, and since no proper
subset was a basis, we have actually found a basis
of~$C\cup\{d\}$.\par\medskip
%
\begin{figure}[tbhp]
\begin{center}
\begin{tabular}{c|c|c|c|c}
bit-string~\code{T} & $T\cup\{d\}$ & primitive($T\cup\{d\}$) &
enclosing($T\cup\{d\}$) \\
\hline
 $000$ & $\{d\}$ & yes & no\\
 $001$ & $\{C_0,d\}$ & yes & no\\
 $010$ & $\{C_1,d\}$ & yes & no\\
 $011$ & $\{C_1,C_0,d\}$ & yes & no\\
 $100$ & $\{C_2,d\}$ & yes & no\\
 $101$ & $\{C_2,C_0,d\}$ & yes & yes\\
 $110$ & $\{C_2,C_1,d\}$ & yes & no\\
 $111$ & $\{C_2,C_1,C_0,d\}$ & no & n/a
\end{tabular}
\caption{\label{fig_pivot_tab}The iteration corresponding to
figure~\ref{fig_pivot}.}
\end{center}
\end{figure}
%
In order to formulate the procedure \code{gen()} without recursion, we
introduce two variables \code{pos} (with the intial value~$0$) and
\code{up} (initially \code{true}), which keep the current position
(i.e., the number of the bit we set or clear) and the current direction
(whether we enter a recursion or whether we return from one).  The
following rules should then be obvious:
\begin{itemize}
\item When bit \code{pos} is cleared, we proceed as follows: If the
direction is ``up,'' we increment~\code{pos}.  Otherwise we set
bit~\code{pos}, increment \code{pos} and change the direction to
``up.''
\item When bit \code{pos} is set, we clear the bit at
position~\code{pos}, decrement \code{pos} and set the direction to
``down.''
\end{itemize}
Notice also that it is not necessary to begin with $\code{pos}=0$; we
can right away start with $\code{pos}=e$, when we initially clear the
bit-string.  This leads to the following framework.\par\medskip
%
@$@<routine pivot()@>==@{@-
template<typename FT>
bool is_better(const FT& old,const FT& now,const Tag_false is_exact) {
  return now > old;
}

template<typename FT>
bool is_better(const FT&,const FT&,const Tag_true is_exact) {
  return true;
}

template<class Traits>
bool Min_sphere_of_spheres_d<Traits>::pivot(const int d) {
  using namespace Min_sphere_of_spheres_d_impl;

  // remember old radius:
  const Result old = ss.radius();

  // reset basis to {d}:
  ss.reset();
  ss.push(*l[d]);

  // try all subsets:
  std::bitset<Traits::D+1> T;
  int pos = e;
  bool up = true;
  while (pos >= 0) {
    if (pos == e) {
      @<check whether T induces a basis, return if so@>
      --pos;
      up = false;
    } else if (!T.test(pos)) {
      if (up)
        ++pos;
      else
        if (ss.push(*l[pos])) {
          T.set(pos,true);
          ++pos;
          up = true;
        } else
          --pos;
    } else {
      ss.pop();
      T.set(pos,false);
      --pos;
      up = false;
    }
  }

  @<no basis was found@>
}
@}\par\medskip%
%
%
In contrast to the routine \code{gen()} above, we do not always set
the bit at line~($\star$); we only do so if \code{push()} returns
true.  Otherwise we know that no superset forms a basis, so we skip
the whole branch of the recursion.  Notice also that the statements
after the while-loop should, at least in theory, never be reached
(because one of the generated subsets \e{is} a basis of~$C\cup\{d\}$).
But since we are dealing with floating-point numbers, we must handle
the case somehow: We take it as a sign that the ball~$d$ was very
close to~$\MB(C)$ and so we don't change the basis at all.\par\medskip
%
@$@<no basis was found@>==@{@-
// Here, no basis has been found (this only happens because
// of rounding errors):
#ifdef CGAL_MINIBALL_WARNINGS
std::cerr << '!';
#endif

// revert basis:
ss.reset();
for (int i=0; i<e; ++i)
  ss.push(*l[i]);
ss.is_spanning();

// signal that we failed:
return false;@}\par\medskip%
%
%Notice also from the pseudo-code version of \code{gen()} that
%\code{output()} is only executed when the last modified bit has been
%\e{set} (and not cleared).  In other words, when \code{pos} equals
%$e$, the last operation on the stack was a \code{push()} and not a
%\code{pop()}.  (We made use of this fact in the implementation of
%class \code{Support\_set} where \code{center} is only computed in
%\code{is\_spanning()}.\par\medskip
%
Finally, checking whether the set~\code{T} constitutes a basis amounts
to calling \code{is\_spanning()} and making sure that the spanned ball
encloses all balls from~$C$.\par\medskip
%
@$@<check whether T induces a basis, return if so@>==@{@-
bool isEnclosingSupporting = ss.is_spanning();
if (isEnclosingSupporting)
  for(int i=0; i<e; ++i)
    if (!T.test(i) && !ss.contains(t.center_cartesian_begin(*l[i]),
                                   t.radius(*l[i]),
                                   Tol,Is_exact())) {
      isEnclosingSupporting = false;
      break;
    }

if (isEnclosingSupporting) {
  // rearrange balls:
  int next = 0;
  for(int i=0; i<e; ++i)
    if (T.test(i))
      std::swap(l[next++],l[i]);
  std::swap(l[next++],l[d]);
  e = next;
  return is_better(old,ss.radius(),Is_exact());
}
@}\par\medskip%
%
Notice that during approximate computaton we return \code{true} only
when a larger radius was found.  Otherwise, we signal a failure.
%
\subsection{The implementation of the LP-algorithm}
%
The LP-algorithm is shown on the left-hand side of
figure~\ref{fig_lpalg}.  Refer to~\cite{msw-sblp-92,f-sebb-01} for
more in\-for\-ma\-tion (and explanations for why it solves our
problem).  It is easily verified that the algorithm can be reformulated
as shown on the right-hand side\note{ (see appendix)}.  This version
works without recursion and uses $O(1)$ stack-space instead
of~$O(n)$. It is this latter variant we are going to
implement.\par\medskip
%
\begin{figure}[tbhp]
\begin{center}
\begin{tabular}{c@@{\hspace*{0.5cm}}c}
\begin{minipage}{1cm}
\begin{tabbing}
\hspace*{.5cm}\=\hspace*{.5cm}\=\hspace*{.5cm}\=\hspace*{.5cm}\kill
{\bf procedure} lpalg($S$,$B$);\\
\{{\rm  Pre: $B\subseteq S$, $B$ a basis }\}\\
\{{\rm  Post: $C$ a basis of~$S$ }\}\\
{\bf begin}\\
\> {\bf if} $S = B$\\
\> \> $C$:= $B$;\\
\> {\bf else}\\
\> \> $D$:= random~$\in S\backslash B$;\\
\> \> $C$:= lpalg($S \backslash \{D\}$,$B$);\\
\> \> {\bf if} {\bf not} contains($D$,$C$)\\
\> \> \> $C$:= lpalg($S$,pivot($C$,$D$));\\
\> {\bf return} $C$;\\
{\bf end} lpalg;\\
\end{tabbing}
\end{minipage}
&
\begin{minipage}{1cm}
\begin{tabbing}
\hspace*{.5cm}\=\hspace*{.5cm}\=\hspace*{.5cm}\=\hspace*{.5cm}\=\hspace*{.5cm}\kill
{\bf procedure} mini($n$);\\
\{{\rm  $S=L[0..(n-1)]$,  $B=L[0..(e-1)]$ }\}\\
\{{\rm  Pre: $B$ a basis, $n\ge e\ge 0$ }\}\\
\{{\rm  Post: $L[0..(e-1)]$ a basis of~$S$ }\}\\
{\bf begin}\\
\> $k$:= $n$;\\
\> {\bf repeat} \\
\> \> {\bf for} $i:= k-1$ {\bf downto} $e$ {\bf do} \\
\> \> \> swap($L$[rand($e..i$)],$L[i]$);\\
\> \> $i$:= $e$;\\
\> \> {\bf while} $i\le n-1$ {\bf do} \\
\> \> \> {\bf if} {\bf not} contains($L[i]$,$L[0..(e-1)]$)\\
\> \> \> \> $e$:= pivot($L,e,L[i]$));\\
\> \> \> \> $k$:= $i+1$;\\
\> \> \> \> {\bf break}\\
\> \> \> $i$:= $i$+1; \\
\> {\bf until} $i=n$\\
{\bf end} mini;\\
\end{tabbing}
\end{minipage}
\end{tabular}
\end{center}
% \begin{center}
% \begin{minipage}{1cm}
% \begin{tabbing}
% \hspace*{.5cm}\=\hspace*{.5cm}\=\hspace*{.5cm}\=\hspace*{.5cm}\kill
% {\bf procedure} lpalg($S$,$B$);\\
% \{{\rm  Pre: $B\subseteq S$, $B$ a basis }\}\\
% \{{\rm  Post: $C$ a basis of~$S$ }\}\\
% {\bf begin}\\
% \> {\bf if} $S = B$ {\bf then}\\
% \> \> $C$:= $B$;\\
% \> {\bf else}\\
% \> \> $D$:= random~$\in S\backslash B$;\\
% \> \> $C$:= lpalg($S \backslash \{D\}$,$B$);\\
% \> \> {\bf if} {\bf not} contains($D$,$C$) {\bf then}\\
% \> \> \> $C$:= lpalg($S$,pivot($C$,$D$));\\
% \> {\bf return} $C$;\\
% {\bf end} lpalg;\\
% \end{tabbing}
% \end{minipage}
% \end{center}
\caption{\label{fig_lpalg} The LP-algorithm (left) and its forumlation
without recursion (right).}
\end{figure}
%
We store  the checked-in balls in a list \code{l} and
allocate a single instance of class \code{Support\_set} for use by
routine \code{pivot()}; it is also this instance which finally
encapsulates the center and the radius of the computed miniball.
Altoghether, the class \code{Min\_\-sphere\_\-of\_spheres\_d} looks as
follows:\par\medskip
%
@$@<declaration of class Min_sphere_of_spheres_d@>==@{@-
template<class Traits>
class Min_sphere_of_spheres_d {
public: // some short hands:
  typedef typename Traits::Sphere Sphere;
  typedef typename Traits::FT FT;
  typedef typename Selector<FT>::Result Result;
  typedef typename Selector<FT>::Is_exact Is_exact;
  typedef typename Traits::Use_square_roots Use_sqrt;
  typedef typename Traits::Algorithm Algorithm;
  static const int D = Traits::D;
  typedef typename Traits::Cartesian_const_iterator CIt;

private: // traits class:
  Traits t; // To allow the traits to not only vary at compile- but
            // also at runtime, we instantiate it here.

private: // for internal consisteny checks:
  // The following variable is true if and only if the miniball
  // has been computed of all inserted balls, i.e.,iff every checked-in
  // ball has been respected in the miniball computation.
  bool is_up_to_date;

public: // iterators:
  typedef const Result *Cartesian_const_iterator; // coordinate iterator

  class Support_iterator {
    typedef typename std::vector<Sphere>::const_iterator It;
    It it;

  private:
    friend class Min_sphere_of_spheres_d<Traits>;
    Support_iterator(It it) : it(it) {}

  public:
    const Sphere& operator*() { return *(*it); }
    Support_iterator& operator++() { ++it; return *this; }
    Support_iterator operator++(int) {
      Support_iterator old(*this);
      ++(*this);
      return old;
    }
    bool operator!=(const Support_iterator& i) { return it != i.it; }
  };

public: // construction and destruction:
  inline Min_sphere_of_spheres_d(const Traits& traits = Traits());

  template<typename InputIterator>
  inline Min_sphere_of_spheres_d(InputIterator begin,InputIterator end,
                                 const Traits& traits = Traits()) :
    t(traits), ss(t), e(0) {
    is_up_to_date = false;
    CGAL_MINIBALL_ASSERT(is_neg(ss.radius(),ss.disc()));
    insert(begin,end);            // todo. better way?
  }

  inline void prepare(int size);

  inline void insert(const Sphere& b);

  template<typename InputIterator>
  inline void insert(InputIterator begin,InputIterator end) {
    prepare(l.size()+(end-begin)); // todo. istream?
    while (begin != end) {
      insert(*begin);
      ++begin;
    }
  }

  inline void clear();

  template<typename InputIterator>
  inline void set(InputIterator begin,InputIterator end) {
    clear();
    insert(begin,end);
  }

public: // predicates and accessors:
  inline bool is_empty();

  inline const Result& radius();

  inline Cartesian_const_iterator center_cartesian_begin();
  inline Cartesian_const_iterator center_cartesian_end();

  inline const FT& discriminant();

  inline Support_iterator support_begin();

  inline Support_iterator support_end();

  inline const Traits& traits() const {
    return t;
  }

public: // validity check:
  bool is_valid();
  bool is_valid(const Tag_true is_exact);
  bool is_valid(const Tag_false is_exact);

private:
  bool pivot(int B);

  void update();
  void update(LP_algorithm);
  void update(Farthest_first_heuristic);

  bool find_farthest(int from,int to,int& i,
                     Tag_true use_sqrt,Tag_false is_exact);
  bool find_farthest(int from,int to,int& i,
                     Tag_true use_sqrt,Tag_true is_exact);
  bool find_farthest(int from,int to,int& i,
                     Tag_false use_sqrt,Tag_false is_exact);
  bool find_farthest(int from,int to,int& i,
                     Tag_false use_sqrt,Tag_true is_exact);

private:
  std::vector<Sphere> S;         // list of the added bals
  std::vector<const Sphere *> l; // list of pointers to the added bals
  Support_set<Traits> ss;        // current support set
  int e;                         // l[0..(e-1)] is a basis

private: // forbid copy constructing and assignment (because our
         // pointers in ss would be wrong then):
  Min_sphere_of_spheres_d(const Min_sphere_of_spheres_d&);
  Min_sphere_of_spheres_d& operator=(const Min_sphere_of_spheres_d&);
};@}\par\medskip%
%
Most methods are straight-forward and are given in
section~\ref{sect_files} without further explanation.  The
implementation of the LP-algorithm from figure~\ref{fig_lpalg} is
almost verbatim:\par\medskip
%
@$@<routine lpalg()@>==@{@-
template<class Traits>
void Min_sphere_of_spheres_d<Traits>::update(LP_algorithm) {
  using namespace Min_sphere_of_spheres_d_impl;
  const int n = l.size();
  int i, k = n;
  do {
    CGAL_MINIBALL_ASSERT(k>=e && e>=0);

    // permute:
    for (int j=k-1; j>=e; --j) // todo. theory: is this necessary?
      std::swap(l[j],l[e+random(j+1-e)]);

    for (i=e; i<n; ++i)
      if (!ss.contains(t.center_cartesian_begin(*l[i]),
                       t.radius(*l[i]),Tol,Is_exact()) && pivot(i)) {
        k = i+1;
        break;
      }
  } while (i < n);
}
@}\par\medskip%
%
This works fine in theory.  However, for approximate computation our
implementation of \code{pivot()} might fail under certain
circumstances.  In such a case we proceed as if the violating ball
were contained in the current ball.  In this way, termination is
guaranteed.
%
\subsection{The implementation of the farthest-first heuristic}
%
The heurist \code{Farthest\_first\_heuristic} is shown in
figure~\ref{fig_heur}.  We start with an initially empty
basis~$B\subseteq S$ and update $B$ in every iteration of the
while-loop to a new basis $B'\subseteq S$ with larger
miniball~$\MB(B')$, provided such a ``better'' basis exists.  Clearly,
a ``better'' basis exists if and only if there is a ball~$L[i]$ which
is not yet contained in~$\MB(B)$.\footnote{In the terminology of
LP-type problems we can rephrase this as: If $B\subseteq S$ is a basis
with value $w(B)$, then there exists a basis~$B'\subseteq S$ with
$w(B')>w(B)$ if and only if there is $x\in S\backslash B$ with
$w(B\cup\{x\})>w(B)$.  (This follows from monotonicity and locality.)}
Therefore, we iterate over all balls: If every single one is contained
in~$\MB(B)$, then there is no better basis than~$B$ in~$S$ and so $B$
is a basis of~$S$.  However, if there is a ball not being contained
in~$\MB(B)$, then we take it to produce a better basis.---Actually, we
do not take any such ``violating'' ball, but we take the one farthest
away from~$\MB(B)$, in the hope of making~$B$ large very rapidly.
%
In figure~\ref{fig_heur_ex}, an iteration step is depicted where
$B=\{B_0,B_1,B_2\}$, currently.  As the next ball, we take~$L[i]$
since this is the one with largest excess with respect
to~$\MB(B)$.\par\medskip
\begin{figure}[tbhp]
\begin{center}
\begin{minipage}{5cm}
\begin{tabbing}
\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}
\kill
{\bf procedure} ff($n$);\\
\{{\rm  Input: $S=L[0..(n-1)]$ }\}\\
\{{\rm  Post: $L[0..(e-1)]$ a basis of~$S$ }\}\\
{\bf begin}\\
\> $e$:= $i$:= 0;\\
\> \{{\rm invariant: $B=L[0..(e-1)]$ is a basis}\} \\
\> enclosing:= $|S|=0$; \{{\rm is $B$ a basis of $S$?}\} \\
\> {\bf while not} enclosing {\bf do} \\
\> \> pivot($L,e,L[i]$);\\
\> \> $i$:= index of $\max_{e\le i<n}$ $\ex_{\MB(B)}$(L[$i$]);\\
\> \> {\bf if} excess(L[$i$]) $\le 0$ {\bf then}\\
\> \> \> enclosing:= true\\
\> {\bf end while}\\
{\bf end} ff;\\
\end{tabbing}
\end{minipage}
\caption{\label{fig_heur}The farthest-first heuristic.}
\end{center}
\end{figure}
%
Although the heuristic as shown in figure~\ref{fig_heur} is correct in
theory, we need to watch out because we are working with inexact
floating-point numbers.  So what happens if the call to \code{pivot()}
fails?  The while-loop will iterate forever!  To avoid this, we catch
the case when \code{pivot()} returns false and terminate immediately,
returning the basis~$B$ we have computed so far, see
figure~\ref{fig_heur_impl}.  Usually, \code{pivot()} tends to fail
when the new ball $D=L[i]$ lies almost on the boundary of the current
miniball~$\MB(B)$.  So we have $\MB(B)\approx \MB(B\cup\{L[i]\})$ when
\code{pivot()} fails.  But since the ball~$L[i]$ was the one farthest
away from~$\MB(B)$, the computed miniball cannot be that bad: The
balls from~$S$ it doesn't contain are all very close to its boundary!
This argument is of course not a strict proof for the robustness of
the heuristic, but it explains why it works well in practice even for
degenerate cases.  (Notice that a failure of \code{pivot()} can happen
at any time in the LP-algorithm (since $D$ is chosen randomly), while
in the heuristic such degenerate cases tend to happen towards the end
of the computation when the ball~$\MB(B)$ is already very
large\ldots)\par\medskip\par\medskip
%
%
\begin{figure}[tbhp]
\begin{center}
\begin{minipage}{5cm}
\begin{tabbing}
\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}
\kill
{\bf procedure} ff($n$);\\
\{{\rm  Input: $S=L[0..(n-1)]$ }\}\\
\{{\rm  Post: $L[0..(e-1)]$ a basis of~$S$ }\}\\
{\bf begin}\\
\> $e$:= $i$:= 0;\\
\> \{{\rm invariant: $B=L[0..(e-1)]$ is a basis}\} \\
\> enclosing:= $|S|=0$; \{{\rm is $B$ a basis of $S$?}\} \\
\> {\bf while not} enclosing {\bf and} pivot($L,e,L[i]$) {\bf do}\\
\> \> $i$:= index of $\max_{s\le i<n}$ $\ex_{\MB(B)}$(L[$i$]);\\
\> \> {\bf if} excess(L[$i$]) $\le 0$ {\bf then}\\
\> \> \> enclosing:= true\\
\> {\bf end while}\\
{\bf end} ff;\\
\end{tabbing}
\end{minipage}
\caption{\label{fig_heur_impl}The implementation of the heuristic.}
\end{center}
\end{figure}
%
%
Here is the implementation of the heuristic.
%
Ignore the call to \code{update()} for the time being; it is discussed
below.
%
\par\medskip
%
@$@<routine farthestfirst()@>==@{@-
template<class Traits>
void Min_sphere_of_spheres_d<Traits>::update(Farthest_first_heuristic) {
  const int n = l.size();
  int i = e;
  CGAL_MINIBALL_ASSERT(e <= n);

  bool enclosing = (e == 0)? n == 0 :
    !find_farthest(e,n,i,Use_sqrt(),Is_exact());

  while (!enclosing && pivot(i)) {
    enclosing = !find_farthest(e,n,i,Use_sqrt(),Is_exact());
  }

  if (!is_approximate(Is_exact()))
    update(LP_algorithm());
}
@}\par\medskip%
%
In case we perform the exact computation, we proceed in a similar
fashion.  Again we search in each round for the ball farthest
away. However, since in this case routine
\code{find\_farthest($\ldots$)} works with floating-point numbers, it
might happen to return false although there exists a ball not yet
contained in \code{ss}!  (Notice that \code{l[i]} is guaranteed not to
be contained in \code{ss} when \code{find\_farthest()} returns true.)
Thus we cannot be sure that we have have found an enclosing ball when
we leave the while-loop.  This is why we call the LP-algorithm to find
us the exact miniball, using the (hopefully) large basis we have
produced so far.\par\medskip
%
\begin{figure}[tbhp]
\begin{center}
\includegraphics{figs/heuristic/excess.eps}
\caption{\label{fig_heur_ex}The idea of the heuristic.}
\end{center}
\end{figure}
%
\subsection{The validity check}
%
According to the specification, we have to check that (i)~the computed
miniball is enclosing, (ii)~that the computed support-set (i.e., the
set of balls returned by \code{support\_begin()} and
\code{support\_end()}) is indeed supporting (i.e., all balls are on
the boundary), (iii)~that it spans the miniball and (iv)~that it is
inclusion-minimal.  While the first two conditions are easily checked,
the third and the fourth can be expressed using
Lemma~\ref{lemma_seidel} as follows.  We compute the
coefficients~$\lambda_i$ of the affine combination
\begin{equation}\label{valid_coeffs}
c = \sum_{i=0}^{e-1} \lambda_i c_i \qquad \mbox{for} \qquad
\sum_{i=0}^{e-1} \lambda_i = 1,
\end{equation}
which expresses the center~$c$ of the computed miniball in terms of
the centers $\{c_0,\ldots,c_{e-1}\}$ of the computed support set.
Condition (iii) then amounts to all coefficients $\gamma_i$ being
non-negative, while condition (iv) requires them to be strictly
positive.\par\medskip
%
Consequently, we start like this:\par\medskip
%
@$@<routine is_valid() (validity check)@>==@{@-
template<class Traits>
bool Min_sphere_of_spheres_d<Traits>::
  is_valid(const Tag_false is_exact) {
@!##   #ifdef CGAL_MINIBALL_WARNINGS
@!##   using namespace std;
@!##   cerr << "Min_sphere_of_spheres_d::is_valid() not supported for inexact number types" << endl;
@!##   #endif
  return true;
}

template<class Traits>
bool Min_sphere_of_spheres_d<Traits>::
  is_valid(const Tag_true is_exact) {
  using namespace Min_sphere_of_spheres_d_impl;
  using std::cerr;
  using std::endl;

  // check size of support set:
  if (e > static_cast<int>(l.size()) || e > (D+1)) {
    cerr << "Min_sphere_of_spheres_d: support set too large." << endl
         << "Please contact the author <kf@@iaeth.ch>." << endl;
    return false;
  } else if (l.size() > 0 && e<=0) {
    cerr << "Min_sphere_of_spheres_d: support set too small." << endl
         << "Please contact the author <kf@@iaeth.ch>." << endl;
    return false;
  }

  // check case of no balls:
  if (l.size() <= 0) {
    if (!is_empty()) {
      cerr << "Min_sphere_of_spheres_d: miniball of {} non-empty." << endl
           << "Please contact the author <kf@@iaeth.ch>." << endl;
      return false;
    } else
      return true;
  }

  @<fail if miniball is not enclosing@>
  @<fail if support set is not supporting@>
  @<compute coefficients@>
  @<fail if support set is not spanning or if it is not minimal@>
  return true;
}
@}\par\medskip
%
The first two checks (i) and~(ii) look as follows.  (The second is
more or less the routine \code{contains()} with the difference that we
want equality in the last statement rather than
inequality.)\par\medskip
%
@$@<fail if miniball is not enclosing@>==@{@-
// check that the miniball is enclosing:
for (unsigned int i=0; i<l.size(); ++i)
  if (!ss.contains(t.center_cartesian_begin(*l[i]),
                   t.radius(*l[i]),Tol,Is_exact())) {
    cerr << "Min_sphere_of_spheres_d: miniball not enclosing." << endl
         << "Please contact the author <kf@@iaeth.ch>." << endl;
    return false;
  }
@}\par\medskip%
%
@$@<fail if support set is not supporting@>==@{@-
// check that all support balls lie on the boundary:
typedef Pair<FT> P;
bool isSupporting = true;
for (int i=0; i<e; ++i) {
  // check radii:
  const P rd = ss.radius()-t.radius(*l[i]);
  if (is_neg(rd,ss.disc()))
    isSupporting = false;

  // compute the (squared) distance from ss.begin() to l[i]'s center:
  const P dist = inner_product_n<D>(ss.begin(),
    t.center_cartesian_begin(*l[i]),P(0,0),std::plus<P>(),
    Subtract_and_square_pair<FT>(ss.disc()));

  // compute the square of rd:
  const P sqrRd(sqr(rd.first)+sqr(rd.second)*ss.disc(),
                FT(2)*rd.first*rd.second);

  // check containment:
  if (!is_zero(dist-sqrRd,ss.disc()))
    isSupporting = false;
}
if (!isSupporting) {
  cerr << "Min_sphere_of_spheres_d: support not on boundary." << endl
       << "Please contact the author <kf@@iaeth.ch>." << endl;
  return false;
}
@}\par\medskip%
%
In order to compute the coefficients from~(\ref{valid_coeffs}), we
solve the following equivalent system of linear equations, whose
coefficient matrix must have full rank (since the points~$c_i$ are
affinely dependent).
%
\begin{equation}\label{valid_coeffs_sys}
\left[
\begin{array}{ccc}
c_0 & \cdots & c_{e-1} \\
1 & \cdots & 1
\end{array}
\right]
\left[
\begin{array}{c}
\lambda_0 \\
\vdots \\
\lambda_{m-1}
\end{array}
\right]
=
\left[
\begin{array}{c}
c \\
1
\end{array}
\right].
\end{equation}
%
%
Using Gaussian elimination we transform (\ref{valid_coeffs_sys}) to a
system whose coefficient matrix is upper-triangular.  Backsubstitution
then yields the coefficients~$\lambda_i$.  In the code below we use
\code{m[$j$][$i$]} to denote the entry $M_{ij}$ of the coefficient
matrix of system~(\ref{valid_coeffs_sys}).\par\medskip
%
@$@<compute coefficients@>==@{@-
// set up initial system's coefficient matrix:
FT (*m)[D+1] = new FT[e][D+1];
for (int j=0; j<e; ++j)
  copy_n<D>(t.center_cartesian_begin(*l[j]),m[j]);
for (int j=0; j<e; ++j)
  m[j][D] = FT(1);

// set up initial system's right-hand-side:
Pair<FT> rhs[D+1];
copy_n<D>(ss.begin(),rhs);
rhs[D] = FT(1);

// perform Gaussian elimination:
for (int j=0; j<e; ++j) {
  // check rank:
  if (m[j][j] == FT(0)) {
    // find row with non-zero entry in column j:
    int i = j;
    while (i<D+1 && m[j][i]==FT(0))
      ++i;
    if (i >= D+1) {
      cerr << "Min_sphere_of_spheres_d: supp. centers aff. dep." << endl
           << "Please contact the author <kf@@iaeth.ch>." << endl;
      return false;
    }

    // exchange rows:
    for (int k=0; k<e; ++k)
      std::swap(m[k][j],m[k][i]);
    std::swap(rhs[j],rhs[i]);
  }
  CGAL_MINIBALL_ASSERT(m[j][j] != FT(0));

  // eliminate m[j][j+1..D] by subtracting a
  // multiple of row j from row i:
  for (int i=j+1; i<D+1; ++i) {
    // determine factor:
    const FT factor = m[j][i]/m[j][j];

    // subtract row j times factor from row i:
    for (int k=0; k<e; ++k)
      m[k][i] -= m[k][j]*factor;
    rhs[i] -= rhs[j]*factor;
  }
}

// check that we now have an upper triangular matrix:
for (int j=0; j<e; ++j)
  for(int i=j+1; i<D+1; ++i)
    CGAL_MINIBALL_ASSERT(m[j][i] == FT(0));

// check solvability:
for (int i=e; i<D+1; ++i)
  if (!is_zero(rhs[i],ss.disc())) {
    cerr << "Min_sphere_of_spheres_d: center of the miniball" << endl
         << "not in the span of the support centers." << endl
         << "Please contact the author <kf@@iaeth.ch>." << endl;
    return false;
  }

// compute coefficients by backsubstitution:
Pair<FT> lambda[D+1];
for (int i=e-1; i>=0; --i) {
  lambda[i] = rhs[i];
  for (int j=i+1; j<e; ++j)
    lambda[i] -= lambda[j]*m[j][i];
  lambda[i] = lambda[i]/m[i][i];
}
@}\par\medskip%
%
@$@<fail if support set is not spanning or if it is not minimal@>==@{@-
// check coefficients:
for (int i=0; i<e; ++i)
  if (is_neg_or_zero(lambda[i],ss.disc())) {
    cerr << "Min_sphere_of_spheres_d: center of miniball not in" << endl
         << "interior of convex hull of support centers." << endl
         << "Please contact the author <kf@@iaeth.ch>." << endl;
    return false;
  }

// tidy up:
delete[] m;
@}\par\medskip%
%
%
\section{The test-suite}
%
Included in the package is the program \code{stability} which computes
the miniball of some sets of balls the miniball of which is known in
advance.  The computed ball is compared to the exact ball and the test
is successful if the relative error in the radius doesfg
 not get too
large.  The actual tests are the following, most being problematic
scenarios with degeneracies:
%
\begin{itemize}
\item Computing the miniball of a set~$S$ of points in $\R^2$ which lie on
a circle.  The test is performed for two sets $S$, one consisting of
some $6000$ points with a small miniball, and one consisting of some
$13000$ points having a larger miniball.
%
\item Computing the miniball of a set~$S$ of $10000$ almost cospherical
points.  This is done for points in $\R^3$ and $\R^{10}$.
%
\item Computing the miniball of $10000$ points obtained from a
tesselation of the unit sphere in $\R^3$ by longitude/latitude values.
%
\item Computing the miniball of $10000$ points in $\R^3$, $\R^5$ and
$\R^{10}$, randomly chosen form the unit cube.
%
\item Computing the miniball of the vertices of the regular simplex in
dimension~$d$, for $d=10$ and $d=15$.
%
\item Computing the miniball of the vertices of the unit cube in $\R^{10}$
and $\R^{12}$.
%
\item Computing the miniball of $10000$ balls (with random radii in
$[0,1)$) which all touch the unit sphere in $\R^2$ and $\R^3$.
%
\end{itemize}
(The first six of the above tests are taken from Bernd Gaertner's
testsuite for his miniball-of-points
\htmladdnormallinkfoot{implementation.}{http://www.inf.ethz.ch/personal/gaertner/miniball.html})\par\medskip
%
Each of the above tests is performed in some additional variations,
obtained by
\begin{itemize}
\item adding 10 copies of each ball,
\item embedding the balls into $\R^D$ for $D=2d$,
\item randomly perturbing the coordinates by $10^{-50}$, $10^{-30}$,
$10^{-10}$ and~$10^{-3}$,
\item computing the miniball using \code{AvoidSqrt} and using
\code{UseSqrt}.
\end{itemize}
So every single of the above eight tests is run in $2\cdot 2\cdot
2\cdot 5=40$ variations.
%
\section{The files}\label{sect_files}
%
%
@$@<header@>@(@1@)@M==@{@-
// ======================================================================
//
// Copyright (c) 1997 The CGAL Consortium
//
// This software and related documentation are part of the Computational
// Geometry Algorithms Library (CGAL).
// This software and documentation are provided "as-is" and without warranty
// of any kind. In no event shall the CGAL Consortium be liable for any
// damage of any kind.
//
// Every use of CGAL requires a license.
//
// Academic research and teaching license
// - For academic research and teaching purposes, permission to use and copy
//   the software and its documentation is hereby granted free of charge,
//   provided that it is not a component of a commercial product, and this
//   notice appears in all copies of the software and related documentation.
//
// Commercial licenses
// - Please check the CGAL web site http://www.cgal.org/index2.html for
//   availability.
//
// The CGAL Consortium consists of Utrecht University (The Netherlands),
// ETH Zurich (Switzerland), Freie Universitaet Berlin (Germany),
// INRIA Sophia-Antipolis (France), Martin-Luther-University Halle-Wittenberg
// (Germany), Max-Planck-Institute Saarbruecken (Germany), RISC Linz (Austria),
// and Tel-Aviv University (Israel).
//
// ----------------------------------------------------------------------
//
// release       : $CGAL_Revision$
// release_date  : $CGAL_Date$
//
// chapter       : $CGAL_Chapter: Optimisation $
// file          : @1
// package       : Min_sphere_of_spheres_d (1.10)
// revision      : $Id$
// revision_date : $Date$
//
// author(s)     : Kaspar Fischer
// maintainer    : Kaspar Fischer <fischerk@@inf.ethz.ch>
// coordinator   : ETH Zurich (Kaspar Fischer)
//
// implementation: dD Smallest Enclosing Sphere of Spheres
// email         : contact@@cgal.org
// www           : http://www.cgal.org
//
// ======================================================================
@}
%
%
@O@<../include/CGAL/Min_sphere_of_spheres_d_configure.h@>==@{@-
@<header@>@(include/CGAL/Min_sphere_of_spheres_d_configure.h@)

#ifndef CGAL_MINIBALL_CONFIGURE
#define CGAL_MINIBALL_CONFIGURE

// Remark: In case you want to fine-tune the code, feel free to change
// the options below.

// Option: Namespace name
//
// Background: By default, all data-structures and routines of the
// package are placed in a namespace called CGAL.  You can
// change this name by altering the following #define.
//
// Default value: CGAL
#define CGAL_MINIBALL_NAMESPACE CGAL

// Option: Assertions
//
// Background: The package contains lots of assertions (i.e.,internal
// consistency checks).  For instance, if assertions are enabled then
// the package will complain when you add balls with negative radii.
// If you disable assertions, such tests will not be made (with the
// advantage that the code is slightly faster).  Do *not* disable
// assertions during development.
//
// Default setting: defined
#ifndef CGAL_NO_ASSERTIONS
#define CGAL_MINIBALL_DEBUG
#endif
#ifdef NDEBUG
#undef  CGAL_MINIBALL_DEBUG
#endif

// (You should not have to alter anything below here.)

// If CGAL is not being used, we need to define certain things:
#ifndef CGAL_VERSION
  namespace CGAL_MINIBALL_NAMESPACE {
    struct Tag_true {};
    struct Tag_false {};
  }
  #define CGAL_MINIBALL_NTS @-

#else
  #include <CGAL/basic.h>
  #define CGAL_MINIBALL_NTS CGAL_NTS
#endif

// Define some assertion macros used in the code.
#ifdef CGAL_MINIBALL_DEBUG
  #define CGAL_MINIBALL_ASSERT(expr) assert(expr)
  #define CGAL_MINIBALL_DO_DEBUG(expr) expr
#else
  #define CGAL_MINIBALL_ASSERT(expr) ;
  #define CGAL_MINIBALL_DO_DEBUG(expr) ;
#endif

// Currently, we include all code in the header files because most
// compilers don't support exporting templates anyway:
#define CGAL_MINIBALL_NO_TEMPLATE_EXPORT

#include <bitset>
#include <sstream>

#endif // CGAL_MINIBALL_CONFIGURE
@}\par\medskip%
%
@O@<../include/CGAL/Min_sphere_of_spheres_d.h@>@{@-
@<header@>@(include/CGAL/Min_sphere_of_spheres_d.h@)

#ifndef CGAL_MINIBALL_MINIBALL
#define CGAL_MINIBALL_MINIBALL

#include <CGAL/Min_sphere_of_spheres_d_configure.h>
#include <cassert>
#include <cstdlib>                 // for std::rand()
#include <cmath>

#include <vector>
#include <iostream>
#include <CGAL/Min_sphere_of_spheres_d_support_set.h>

namespace CGAL_MINIBALL_NAMESPACE {

  struct LP_algorithm {};
  struct Farthest_first_heuristic {};
  typedef Farthest_first_heuristic Default_algorithm;

  @<routine compare()@>

  @<declaration of class Min_sphere_of_spheres_d@>

  template<class Traits>
  Min_sphere_of_spheres_d<Traits>::
    Min_sphere_of_spheres_d(const Traits& traits) :
    t(traits), ss(t), e(0) {
    is_up_to_date = true;
    CGAL_MINIBALL_ASSERT(is_neg(ss.radius(),ss.disc())); // makes sure
               // that initially no ball is enclosed (cf. contains()).
  }

  template<class Traits>
  void Min_sphere_of_spheres_d<Traits>::prepare(int size) {
    S.reserve(size);
    l.reserve(size);
  }

  template<class Traits>
  void Min_sphere_of_spheres_d<Traits>::insert(const Sphere& b) {
    CGAL_MINIBALL_ASSERT(t.radius(b) >= FT(0));
    S.push_back(b);
    l.push_back(&b);
    is_up_to_date = false;
  }

  template<class Traits>
  void Min_sphere_of_spheres_d<Traits>::clear() {
    S.clear();
    l.clear();
    ss.reset();
    e = 0;
    is_up_to_date = true;
  }

  template<class Traits>
  bool Min_sphere_of_spheres_d<Traits>::is_empty() {
    if (!is_up_to_date)
      update();
    return is_neg(ss.radius(),ss.disc());
  }

  template<class Traits>
  const typename Min_sphere_of_spheres_d<Traits>::Result&
    Min_sphere_of_spheres_d<Traits>::radius() {
    if (!is_up_to_date)
      update();
    CGAL_MINIBALL_ASSERT(!is_empty());
    return ss.radius();
  }

  template<class Traits>
  typename Min_sphere_of_spheres_d<Traits>::Cartesian_const_iterator
    Min_sphere_of_spheres_d<Traits>::center_cartesian_begin() {
    if (!is_up_to_date)
      update();
    CGAL_MINIBALL_ASSERT(!is_empty());
    return ss.begin();
  }

  template<class Traits>
  typename Min_sphere_of_spheres_d<Traits>::Cartesian_const_iterator
    Min_sphere_of_spheres_d<Traits>::center_cartesian_end() {
    if (!is_up_to_date)
      update();
    CGAL_MINIBALL_ASSERT(!is_empty());
    return ss.begin()+D;
  }

  template<class Traits>
  const typename Min_sphere_of_spheres_d<Traits>::FT&
    Min_sphere_of_spheres_d<Traits>::discriminant() {
    if (!is_up_to_date)
      update();
    CGAL_MINIBALL_ASSERT(!is_empty());
    return ss.disc();
  }

  template<class Traits>
  inline void Min_sphere_of_spheres_d<Traits>::update() {
    update(Algorithm());
    is_up_to_date = true;
@!##     CGAL_MINIBALL_ASSERT(is_valid(Is_exact()));
  }

  template<class Traits>
  inline bool Min_sphere_of_spheres_d<Traits>::is_valid() {
    if (!is_up_to_date)
      update();
    return is_valid(Is_exact());
  }

  template<class Traits>
  inline typename Min_sphere_of_spheres_d<Traits>::Support_iterator
    Min_sphere_of_spheres_d<Traits>::support_begin() {
    if (!is_up_to_date)
      update();
    return Support_iterator(*l.begin());
  }

  template<class Traits>
  inline typename Min_sphere_of_spheres_d<Traits>::Support_iterator
    Min_sphere_of_spheres_d<Traits>::support_end() {
    if (!is_up_to_date)
      update();
    return Support_iterator(*l.begin()+e);
  }

} // namespace CGAL_MINIBALL_NAMESPACE

// If the package is used with CGAL, we include some default
// traits classes:
#ifdef CGAL_VERSION
#include <CGAL/Min_sphere_of_spheres_d_traits_d.h>
#include <CGAL/Min_sphere_of_spheres_d_traits_2.h>
#include <CGAL/Min_sphere_of_spheres_d_traits_3.h>
#endif

#ifdef CGAL_MINIBALL_NO_TEMPLATE_EXPORT
#include <CGAL/Min_sphere_of_spheres_d.C>
#include <CGAL/Min_sphere_of_spheres_d_pivot.C>
#endif

#endif // CGAL_MINIBALL_MINIBALL
@}\par\medskip%
%
%
@O@<../include/CGAL/Min_sphere_of_spheres_d.C@>@{@-
@<header@>@(include/CGAL/Min_sphere_of_spheres_d.C@)

#ifndef CGAL_MINIBALL_MINIBALL_C
#define CGAL_MINIBALL_MINIBALL_C

#include <numeric>
#include <CGAL/Min_sphere_of_spheres_d.h>

#ifdef CGAL_MINIBALL_DEBUG
#include <iostream>
#endif

#include <cstdlib>
#include <algorithm>
#include <CGAL/Min_sphere_of_spheres_d.h>

namespace CGAL_MINIBALL_NAMESPACE {

  // Returns a random number uniformly in {0,...,k-1}.
  inline int random(int k) {
    return std::rand() % k; // todo.  This is not good...
  }

  @<routine lpalg()@>
  @<routine find_farthest() with sqrt@>
  @<routine find_farthest() without sqrt@>
  @<routine farthestfirst()@>
  @<routine is_valid() (validity check)@>

} // namespace CGAL_MINIBALL_NAMESPACE

#endif // CGAL_MINIBALL_MINIBALL_CC
@}\par\medskip%
%
%
@O@<../include/CGAL/Min_sphere_of_spheres_d_support_set.h@>@{@-
@<header@>@(include/CGAL/Min_sphere_of_spheres_d_support_set.h@)

#ifndef CGAL_MINIBALL_SUPPORTSET
#define CGAL_MINIBALL_SUPPORTSET

#include <utility>
#include <functional>
#include <cmath>
#include <CGAL/Min_sphere_of_spheres_d_configure.h>

namespace CGAL_MINIBALL_NAMESPACE {

  namespace Min_sphere_of_spheres_d_impl {
    const double Min_float = 1.0e-120;
    const double Eps = 1.0e-16;
    const double SqrOfEps = 1.0e-32;
    const double Tol = 1.0+Eps;
  }

  template<typename FT>
  inline FT sqr(const FT& x) {
    return x*x;
  }

  // We do not use std::inner_product() because in our case the number n
  // of operands is known.  An optimizing compiler like GCC thus unrolls
  // the following loop.  The same holds for copy_n().
  template<int N,typename T,
           typename InputIterator1,typename InputIterator2,
           typename BinaryOperation1,typename BinaryOperation2>
  inline T
  inner_product_n(InputIterator1 first1,InputIterator2 first2,T init,
                  BinaryOperation1 op1,BinaryOperation2 op2) {
    for (int i=0; i<N; ++i, ++first1, ++first2)
      init = op1(init,op2(*first1,*first2));
    return init;
  }

  template<int N,typename InputIterator,typename OutputIterator>
  inline void copy_n(InputIterator first,OutputIterator result) {
    for (int i=0; i<N; ++i, ++first, ++result)
      *result = *first;
  }

  inline bool is_approximate(const Tag_false is_exact) {
    return true;
  }

  inline bool is_approximate(const Tag_true is_exact) {
    return false;
  }

  @<definition of class Pair@>

  @<type-selector for type Result@>

  @<useful functors@>
  @<definition of class Support_set@>

  template<class Traits>
  Support_set<Traits>::Support_set(Traits& traits) : t(traits) {
    reset();
  }

  template<class Traits>
  void Support_set<Traits>::reset() {
    m = 0;
    sol[0] = FT(-1);
    discrim[0] = FT(0);
    CGAL_MINIBALL_DO_DEBUG(is_spanning_was_called = true);
  }

  template<class Traits>
  const typename Support_set<Traits>::Result&
    Support_set<Traits>::radius() const {
    CGAL_MINIBALL_ASSERT(is_spanning_was_called);
    return sol[m];
  }

  template<class Traits>
  const typename Support_set<Traits>::Result
    *Support_set<Traits>::begin() const {
    CGAL_MINIBALL_ASSERT(is_spanning_was_called);
    return center;
  }

  template<class Traits>
  const typename Support_set<Traits>::FT&
    Support_set<Traits>::disc() const {
    CGAL_MINIBALL_ASSERT(is_spanning_was_called);
    return discrim[m];
  }

  @<routine pop()@>
  @<routine find_radius()@>
} // namespace CGAL_MINIBALL_NAMESPACE

#ifdef CGAL_MINIBALL_NO_TEMPLATE_EXPORT
#include <CGAL/Min_sphere_of_spheres_d_support_set.C>
#endif

#endif // CGAL_MINIBALL_SUPPORTSET
@}\par\medskip%
%
@O@<../include/CGAL/Min_sphere_of_spheres_d_support_set.C@>@{@-
@<header@>@(include/CGAL/Min_sphere_of_spheres_d_support_set.C@)

#ifndef CGAL_MINIBALL_SUPPORTSET_C
#define CGAL_MINIBALL_SUPPORTSET_C

#include <CGAL/Min_sphere_of_spheres_d_support_set.h>

namespace CGAL_MINIBALL_NAMESPACE {

  @<routine reject()@>
  @<routine push()@>
  @<routine is_spanning()@>

} // namespace CGAL_MINIBALL_NAMESPACE

#endif // CGAL_MINIBALL_SUPPORTSET_CC
@}\par\medskip%
%
@O@<../include/CGAL/Min_sphere_of_spheres_d_pivot.C@>@{@-
@<header@>@(include/CGAL/Min_sphere_of_spheres_d_pivot.C@)

#ifndef CGAL_MINIBALL_PIVOT_C
#define CGAL_MINIBALL_PIVOT_C

#include <CGAL/Min_sphere_of_spheres_d.h>

namespace CGAL_MINIBALL_NAMESPACE {

  @<routine pivot()@>
} // namespace CGAL_MINIBALL_NAMESPACE

#endif // CGAL_MINIBALL_PIVOT_CC
@}\par\medskip%
%
\begin{appendix}
\section{Reformulation of the LP-algorithm}
%
Implementing the LP-algorithm the way it is shown on the left of
figure~\ref{fig_step1} is not a goog idea.  The recursion depth is
$O(n)$, $n$ being the initial size of~$S$.  So we reformulate the
algorithm, trying to eliminate the recursion.\par\medskip

As a first step (figure~\ref{fig_step1}) consider the same algorithm
but this time with the set $S$ as an (ordered) list $L[0..(n-1)]$
containing $B$ in $L[0..(e-1)]$.  Like in the original algorithm, copy
semantics is used in argument passing.  The program is initially
called as \code{mini2($L$,$n$,$0$)}.\par\medskip
%
\begin{figure}[htbp]
\begin{center}
\begin{tabular}{c@@{\hspace*{1cm}}c}
\begin{minipage}{1cm}
\begin{tabbing}
\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\kill
{\bf procedure} lpalg($S$,$B$);\\
\\
\{{\rm  Pre: $B\subseteq S$, $B$ a basis }\}\\
\{{\rm  Post: $C$ a basis of~$S$ }\}\\
{\bf begin}\\
\> {\bf if} $S = B$ {\bf then}\\
\> \> $C$:= $B$;\\
\> {\bf else}\\
\\
\> \> $D$:= random~$\in S\backslash B$;\\
\> \> $C$:= lpalg($S \backslash \{D\}$,$B$);\\
\> \> {\bf if} {\bf not} contains($D$,$C$) {\bf then}\\
\> \> \> $C$:= lpalg($S$,pivot($C$,$D$));\\
\> {\bf return} $C$;\\
{\bf end} lpalg;\\
\end{tabbing}
\end{minipage}
&
\begin{minipage}{1cm}
\begin{tabbing}
\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\kill
{\bf procedure} mini2($L$,$k$,$e$);\\
\{{\rm  $S=L[0..(k-1)]$,  $B=L[0..(e-1)]$ }\}\\
\{{\rm  Pre: $k\ge e\ge 0$, $B$ a basis }\}\\
\{{\rm  Post: $C$ a basis of~$S$ }\}\\
{\bf begin}\\
\> {\bf if} $k = e$ {\bf then}\\
\> \> $C$:= $L[0..(e-1)]$;\\
\> {\bf else}\\
\> \> swap($L$[rand($e..(k-1)$)],$L[k-1]$);\\
\> \> $D$:= $L[k-1]$; \{ ($\star$) \}\\
\> \> $C$:= mini2($L,k-1,e$);\\
\> \> {\bf if} {\bf not} contains($D$,$C$) {\bf then}\\
\> \> \> $C$:= mini2($L$,$k$,pivot($L,C,k-1$));\\
\> {\bf return} $C$;\\
{\bf end} mini2;\\
\end{tabbing}
\end{minipage}
\end{tabular}
\end{center}
\caption{\label{fig_step1}From sets to lists.}
\end{figure}
%
The call $e':= \mathrm{pivot}(L,C,k-1)$ computes a basis $B'$ of the
balls $C\cup\{L[k-1]\}$, having size $|B'|\le k$ (because $|C|\le
k-1$).  Furthermore it reorders the lower part $L[0..(k-1)]$ of the
list $L$ and returns a number $e'\le k$ such that $B'=L[0..(e'-1)]$.
Notice that $L$ is passed as a Pascal var-argument (reference
semantics) in the call $\mathrm{pivot}(L,C,k)$, and that the upper
part $L[k..(n-1)]$ is not altered.  (In all other places, copy
semantics is used.)  It should be pretty obvious that algorithms lpalg
and mini2 are identical except for their representation of the sets
$S$ and~$B$.\par\medskip
%
\begin{figure}[htbp]
\begin{center}
\begin{tabular}{c@@{\hspace*{0.4cm}}c}
\begin{minipage}{1cm}
\begin{tabbing}
\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\kill
{\bf procedure} mini3($L$,$k$,$e$);\\
\{{\rm  $S=L[0..(k-1)]$,  $B=L[0..(e-1)]$ }\}\\
\{{\rm  Pre: $k\ge e\ge 0$, $B$ a basis }\}\\
\{{\rm  Post: $C$ a basis of~$S$ }\}\\
{\bf begin}\\
\> {\bf if} $k = e$ {\bf then}\\
\> \> $C$:= $L[0..(e-1)]$; \{ ($\star\star$) \}\\
\> {\bf else}\\
\> \> swap($L$[rand($e..(k-1)$)],$L[k-1]$);\\
\> \> $C$:= mini3($L,k-1,e$);\\
\> \> {\bf if} {\bf not} contains($L[k-1]$,$C$) {\bf then}\\
\> \> \> $C$:= mini3($L$,$k$,pivot($L,C,k-1$));\\
\> {\bf return} $C$;\\
{\bf end} mini3;\\
\end{tabbing}
\end{minipage}
&
\begin{minipage}{1cm}
\begin{tabbing}
\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\kill
{\bf procedure} mini4($k$);\\
\{{\rm  $S=L[0..(k-1)]$,  $B=L[0..(e-1)]$ }\}\\
\{{\rm  Pre: $B$ a basis, $k\ge e\ge 0$ }\}\\
\{{\rm  Post: $C=L[0..(c-1)]$ is a basis of~$S$ }\}\\
{\bf begin}\\
\> {\bf if} $k = e$\\
\> \> $c$:= $e$;\\
\> {\bf else}\\
\> \> swap($L$[rand($e..(k-1)$)],$L[k-1]$);\\
\> \> c:= mini4($k-1$,e);\\
\> \> {\bf if} {\bf not} contains($L[k-1]$,$L[0..(c-1)]$)\\
\> \> \> $c$:= mini4(k,pivot($L,c,k-1$));\\
\> {\bf return} c;\\
{\bf end} mini4;\\
\end{tabbing}
\end{minipage}
\end{tabular}
\end{center}
\caption{\label{fig_step2}From set~$C$ to integer~$c$.}
\end{figure}
%
Up to now L was always copied when a call to mini2 was made.  This is
very inefficent, and the following two observations help us to get rid of
it:
\begin{itemize}
\item[(i)] The call mini2($L$,$k$,$e$) and all the subcalls it makes never
look at (let alone change) the upper elements $L[k..(n-1)]$ in their
respective copies of the list $L$.
%
\item[(ii)] Whenever mini2($L$,$k$,$e$) reaches the end of line~($\star$),
it will never ever look at (let alone change) the lower elements
$L[0..k-1]$ of its own list $L$ anymore (altough the routines which
$\mathrm{mini2}(L,k,e)$ calls might do so): So below ($\star$)
$\mathrm{mini2}(L,k,e)$ doesn't care about the order of the elements
$L[0..(k-1)]$.
\end{itemize}
%
So when $\mathrm{mini2}(L,k,e)$ is about to call itself recursively,
it can pass $L$ as a reference to the subcall
$\mathrm{mini2}(L,\ldots)$, because by~(i) the subcall will not change
the upper part of $L$, and by~(ii) it doesn't matter for
$\mathrm{mini2}(L,k,e)$ if the subcall changes the order of the
elemens in the lower part of $L$.  Notice also that by~(i) the first
recursive call doesn't change $L[k-1]$ neither, so there is no need to
assign it to a variable~$D$ before recursing.  This leads us to mini3
in figure~\ref{fig_step2}.\par\medskip
%
Before we eliminate the recursion, let's have a look at the set~$C$.
Observe that whenever the flow returns from one of the subcalls to
mini3, the last statement which has been performed was of the form
($\star\star$), so $C$ actually coincides with some prefix
$L[0..(c-1)]$ for some~$c$.  This suggest that the algorithm returns
this $c$ (instead of a set $C$), and that $C$ is implicitly given as
$C=L[1..(c-1)]$.  This is how we arrive at mini4.  The call $e':=
\mathrm{pivot}(L,c,k)$ is exactly like pivot above, except that $C$ is
implicitly given as $L[0..(c-1)]$.  Notice that $e$ need not be
locally kept; we can make it a global variable.\par\medskip
%
\begin{figure}[htbp]
\begin{center}
\begin{tabular}{c@@{\hspace*{0.4cm}}c}
\begin{minipage}{1cm}
\begin{tabbing}
\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\kill
{\bf procedure} mini4($k$);\\
\{{\rm  $S=L[0..(k-1)]$,  $B=L[0..(e-1)]$ }\}\\
\{{\rm  Pre: $B$ a basis, $k\ge e\ge 0$ }\}\\
\{{\rm  Post: $C=L[0..(c-1)]$ is a basis of~$S$ }\}\\
{\bf begin}\\
\> {\bf if} $k = e$\\
\> \> $c$:= $e$;\\
\> {\bf else}\\
\> \> swap($L$[rand($e..(k-1)$)],$L[k-1]$);\\
\> \> c:= mini4($k-1$,e);\\
\> \> {\bf if} {\bf not} contains($L[k-1]$,$L[0..(c-1)]$)\\
\> \> \> $c$:= mini4(k,pivot($L,c,k-1$));\\
\> {\bf return} c;\\
{\bf end} mini4;\\
\end{tabbing}
\end{minipage}
&
\begin{minipage}{7.5cm}
\begin{tabbing}
\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\kill
{\bf procedure} mini5($k$);\\
\{{\rm  $S=L[0..(k-1)]$,  $B=L[0..(e-1)]$ }\}\\
\{{\rm  Pre: $B$ a basis, $k\ge e\ge 0$ }\}\\
\{{\rm  Post: $L[0..(e-1)]$ a basis of~$S$ }\}\\
\{{\rm  Initially, $e=0$. }\}\\
{\bf begin}\\
\> {\bf for} $i:= k-1$ {\bf downto} $e$ {\bf do} \\
\> \> swap($L$[rand($e..i$)],$L[i]$);\\
\\
\> {\bf for} $i:= e$ {\bf to} $k-1$ {\bf do} \\
\> \> {\bf if} {\bf not} contains($L[i]$,$L[0..(e-1)]$)\\
\> \> \> $e$:= pivot($L,e,L[i]$));\\
\> \> \> mini5($i+1$); \{ ($\star\star\star$) \}\\
{\bf end} mini5;\\
\end{tabbing}
\end{minipage}
\end{tabular}
\end{center}
\caption{\label{fig_step3}From two to one recursions.}
\end{figure}
%
It's time to tackle the first recursion (i.e., the first call to
mini4).  The algorithm, called as $\mathrm{mini4}(n)$, takes a random
element in $L[0..(n-1)]$, moves it to the end of the list and calls
itself with $n$ decresed by one.  Here, a random element from
$L[0..(n-2)]$ is chosen again, moved to the next-to-last place (i.e.,
to $L[n-2]$) and a recursive call is issued once more.  This game
continues until $k=0$.  Now one element $L[i]$ after the other (with
$i$ going from $0$ to $n-1$) is checked for violation (i.e., not being
contained).  If it doesn't violate~$C$, the recursion goes up one
level, if it does violate $C$, then pivot is called and a "second"
recursive call takes place.  This justifies the following
reformulation of mini5 in figure~\ref{fig_step3}.\par\medskip
%
\begin{figure}[htbp]
\begin{center}
\begin{tabular}{c@@{\hspace*{0.4cm}}c}
\begin{minipage}{7.5cm}
\begin{tabbing}
\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\kill
{\bf procedure} mini5($k$);\\
\{{\rm  $S=L[0..(k-1)]$,  $B=L[0..(e-1)]$ }\}\\
\{{\rm  Pre: $B$ a basis, $k\ge e\ge 0$ }\}\\
\{{\rm  Post: $L[0..(e-1)]$ a basis of~$S$ }\}\\
\{{\rm  Initially, $e=0$. }\}\\
{\bf begin}\\
\> {\bf for} $i:= k-1$ {\bf downto} $e$ {\bf do} \\
\> \> swap($L$[rand($e..i$)],$L[i]$);\\
\\
\> {\bf for} $i:= e$ {\bf to} $k-1$ {\bf do} \\
\> \> {\bf if} {\bf not} contains($L[i]$,$L[0..(e-1)]$)\\
\> \> \> $e$:= pivot($L,e,L[i]$));\\
\> \> \> mini5($i+1$);\\
{\bf end} mini5;\\
\end{tabbing}
\end{minipage}
&
\begin{minipage}{7.5cm}
\begin{tabbing}
\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\=\hspace*{.3cm}\kill
{\bf procedure} mini($n$);\\
\{{\rm  $S=L[0..(n-1)]$,  $B=L[0..(e-1)]$ }\}\\
\{{\rm  Pre: $B$ a basis, $n\ge e\ge 0$ }\}\\
\{{\rm  Post: $L[0..(e-1)]$ a basis of~$S$ }\}\\
{\bf begin}\\
\> $k$:= $n$;\\
\> {\bf repeat} \\
\> \> {\bf for} $i:= k-1$ {\bf downto} $e$ {\bf do} \\
\> \> \> swap($L$[rand($e..i$)],$L[i]$);\\
\> \> $i$:= $e$;\\
\> \> {\bf while} $i\le n-1$ {\bf do} \\
\> \> \> {\bf if} {\bf not} contains($L[i]$,$L[0..(e-1)]$)\\
\> \> \> \> $e$:= pivot($L,e,L[i]$));\\
\> \> \> \> $k$:= $i+1$;\\
\> \> \> \> {\bf break}\\
\> \> \> $i$:= $i$+1; \\
\> {\bf until} $i=n$\\
{\bf end} mini;\\
\end{tabbing}
\end{minipage}
\end{tabular}
\end{center}
\caption{\label{fig_step4}Eliminating the second recursion.}
\end{figure}
%
%
Let's eliminate the second (remaining) recursion.  To this end,
consider the initial call $\mathrm{mini5}(n)$: First, the elements of
$L$ are permuted and then the second for-loop is entered which runs
from $0$ to $n-1$.  Now consider the moment when the first subcall
($\star\star\star$) is taken.  It will cause the elements $L[0..i]$ to
be permuted, whereupon the second for-loop is entered again, this time
running from $0$ to~$i$.  When this loop is done, control returns to
the original for loop which was interrupted at $i$, and now continues
without any further action taken.  (When $i=n$ is reached, the process
stops.) So we can resolve this "tail-recursion" to the final version
mini in figure~\ref{fig_step4}.
%
\end{appendix}
%
%
\bibliography{Refs}
%
\end{document}
