% $Id$
% $Date$
% author : Sylvain Pion

\begin{ccRefClass} {Lazy_exact_nt<NT>}
%\subsection{Lazy wrapper for exact number types\label{lazy_exact_nt}}

\ccDefinition
An object of the class \ccc{Lazy_exact_nt<NT>} is able to represent any 
real embeddable number which \ccc{NT} is able to represent.
The idea is that \ccc{Lazy_exact_nt<NT>} works exactly like \ccc{NT}, except
that it is expected to be faster because it tries to only compute an 
approximation of the value, and only refers to \ccc{NT} when needed.  
The goal is to speed up exact computations done by any exact but slow 
number type \ccc{NT}.\\

\ccc{NT} must be a model of concept \ccc{RealEmbeddable}. \\
\ccc{NT} must be at least model of concept \ccc{IntegralDomainWithoutDivision}.\\


Note that some filtering mechanism is available at the predicate level
using \ccc{Filtered_predicate} and \ccc{Filtered_kernel}.

\ccInclude{CGAL/Lazy_exact_nt.h}

\ccIsModel
\begin{tabular}{ll}
\ccc{IntegralDomainWithoutDivision} & same as \ccc{NT}\\
\ccc{RealEmbeddable}&\\
\ccc{Fraction} & if \ccc{NT} is a \ccc{Fraction}\\
\end{tabular}       
        

\ccCreation
\ccCreationVariable{m}

\ccConstructor{Lazy_exact_nt();}
{introduces an uninitialized variable \ccVar.}
\ccGlue
%\ccConstructor{Lazy_exact_nt(const Lazy_exact_nt &);}
%{copy constructor.}
%\ccGlue
\ccConstructor{Lazy_exact_nt(builtin x)}
{introduces the value \ccc{x}, of any builtin arithmetic type (int, double, etc) (works only if \ccc{NT} has a constructor from this type too).}
\ccGlue
\ccConstructor{Lazy_exact_nt(NT n)}
{introduces the value \ccc{n}.}
\ccGlue
\ccConstructor{template <class NT1> Lazy_exact_nt(Lazy_exact_nt<NT1> n)}
{introduces the value \ccc{n}. \ccc{NT1} needs to be convertible to \ccc{NT}
(and this conversion will only be done if necessary).}

\ccOperations

\ccMethod{NT exact();} {returns the corresponding NT value.}

\ccMethod{Interval_nt<true> approx();} {returns an interval containing the
exact value.}

\ccMethod{Interval_nt<false> interval();} {returns an interval containing the 
exact value.}

\ccMethod{static void set_relative_precision_of_to_double(double d);}
{specifies the relative precision that \ccc{to_double()} has to fulfill.
The default value is $10^{-5}$.  \ccPrecond{d>0 and d<1.}}

\ccMethod{static double get_relative_precision_of_to_double();}
{returns the relative precision that \ccc{to_double()} currently fulfills.}

\ccFunction{std::ostream& operator<<(std::ostream& out,
                                     const Lazy_exact_nt<NT>& m);}
{writes \ccc{m} to ostream \ccc{out} in an interval format.}

\ccFunction{std::istream& operator>>(std::istream& in, Lazy_exact_nt<NT>& m);}
{reads a \ccc{NT} from \ccc{in}, then converts it to a \ccc{Lazy_exact_nt<NT>}.}

\ccExample

\begin{verbatim}
#include <CGAL/Cartesian.h>
#include <CGAL/MP_Float.h>
#include <CGAL/Lazy_exact_nt.h>
#include <CGAL/Quotient.h>

typedef CGAL::Lazy_exact_nt<CGAL::Quotient<CGAL::MP_Float> > NT;
typedef CGAL::Cartesian<NT> K;
\end{verbatim}

\end{ccRefClass} 

